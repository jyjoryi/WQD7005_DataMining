*------------------------------------------------------------*
User:                tan.joryi
Date:                22 December 2019
Time:                20:01:56 o'clock
Site:                12600285
Platform:            X64_8PRO
Maintenance Release: 9.04.01M3P062415
EM Version:          14.1
* 
*------------------------------------------------------------*
* Training Log
Date:                22 December 2019
Time:                20:01:41 o'clock
*------------------------------------------------------------*
14715  proc freq data=EMWS1.TSESM_VariableSet noprint;
14716  table ROLE*LEVEL/out=WORK.TSESMMETA;
14717  run;
 
NOTE: There were 14 observations read from the data set EMWS1.TSESM_VARIABLESET.
NOTE: The data set WORK.TSESMMETA has 5 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.17 seconds
      cpu time            0.01 seconds
 
 
14718  proc print data=WORK.TSESMMETA label noobs;
14719  var ROLE LEVEL COUNT;
14720  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
14721  title9 ' ';
14722  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
14723  run;
 
NOTE: There were 5 observations read from the data set WORK.TSESMMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.13 seconds
      cpu time            0.04 seconds
 
 
14724  title10;
 
14725  %let EMEXCEPTIONSTRING=;
15074  *------------------------------------------------------------*;
15075  * TSESM: Generation of macros and macro variables;
15076  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15077  *------------------------------------------------------------*;
 
15078  %let EMEXCEPTIONSTRING=;
15079  *------------------------------------------------------------*;
15080  * TRAIN: TSESM;
15081  *------------------------------------------------------------*;
15082  %let EM_ACTION = TRAIN;
15083  %let syscc = 0;
15084
15085  %macro EM_TSESM_MAIN;
15086
15087     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
15088     %include temp;
15089     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
15090     %include temp;
15091     filename temp;
15092
15093     %if %upcase(&EM_ACTION) = CREATE %then %do;
15094         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
15095         %include temp;
15096         filename temp;
15097         %EM_TSESM_CREATE;
15098     %end;
15099     %else
15100     %if %upcase(&EM_ACTION) = TRAIN %then %do;
15101          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
15102             %include temp;
15103             filename temp;
15104          %EM_TSESM_TRAIN;
15105     %end;
15106     %else
15107     %if %upcase(&EM_ACTION) = SCORE %then %do;
15108             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
15109             %include temp;
15110             filename temp;
15111           %EM_TSESM_SCORE;
15112     %end;
15113     %else
15114     %if %upcase(&EM_ACTION) = REPORT %then %do;
15115             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
15116             %include temp;
15117             filename temp;
15118            %EM_TSESM_REPORT;
15119     %end;
15120  %mend EM_TSESM_MAIN;
15121  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
15122 +/*----------------------------------------------------------------------------------+
15123 + |
15124 + |   Title :  Time Series data Mining Forcating Macros
15125 + |
15126 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
15127 + |
15128 + |
15129 + +-----------------------------------------------------------------------------------*/
15132 +%macro EM_TSESM_Forecast(indata=,
15133 +                method=,
15134 +                timeinterval=,
15135 +                timeid= ,
15136 +                target= ,
15137 +                tsidvar=,
15138 +                lead=,
15139 +                back=,
15140 +                startsum=,
15141 +                accumulate=,
15142 +                seasonality=,
15143 +                alpha=,
15144 +                extendedvalue=,
15145 +                outest = ,
15146 +                outdata = ,
15147 +                outfor = ,
15148 +                outstat = ,
15149 +                outsum=
15150 +   );
15153 +   %if &tsidvar eq _SEGMENT_ %then %do;
15154 +       proc sort data=&indata out=_tmpdata;
15155 +            by  &tsidvar %EM_CROSSID &timeid ;
15156 +       run;
15157 +       proc timeseries  data =_tmpdata out=_tmpdata;
15158 +            by  &tsidvar %EM_CROSSID;
15159 +            id &timeid interval=&timeinterval accumulate=&accumulate;
15160 +            var &target / ;
15161 +       run;
15162 +       proc esm data =_tmpdata
15163 +   %end;
15164 +   %else %do;
15165 +       proc sort data= &indata out=_tmpdata;
15166 +            by  &tsidvar %EM_CROSSID &timeid ;
15167 +       run;
15168 +       proc esm data = _tmpdata
15169 +   %end;
15170 +            lead=&lead  back=&back startsum=&startsum
15172 +   %if &seasonality ne DEFAULT %then %do;
15173 +            seasonality = &seasonality
15174 +   %end;
15177 +            out=&outdata
15178 +            outest=&outest
15179 +            outfor =&outfor
15180 +            outstat=&outstat
15181 +            outsum= &outsum
15182 +       ;
15183 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
15185 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15186 +            %if &target ne %then %do;
15187 +            forecast &target   /  model = none alpha=&alpha;
15188 +            %end;
15189 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15190 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
15191 +            %end;
15192 +        %end;
15193 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
15194 +            %if &target ne %then %do;
15195 +            forecast &target /  model =&method alpha=&alpha;
15196 +            %end;
15197 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15198 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
15199 +            %end;
15200 +        %end;
15201 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
15202 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
15203 +        %end;
15205 +   %if &tsidvar ne %then %do;
15206 +        by &tsidvar %EM_CROSSID ;
15207 +   %end;
15208 +   run;
15209 +%mend EM_TSESM_Forecast;
15212 +%macro EM_TSESM_CreateOutFor(indata=,
15213 +                            target=,
15214 +                            timeid=,
15215 +                            tsidVar=,
15216 +                            percent=,
15217 +                            outdata=);
15219 +  %let lowerBound = L&percent;
15220 +  %let upperBound = U&percent;
15222 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
15223 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
15224 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
15225 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
15226 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
15227 +       ds_std(rename=(&target=STD) drop=_TYPE_);
15228 +     set &indata;
15229 +       if _TYPE_="FORECAST" then output ds_fore;
15230 +       if _TYPE_="RESIDUAL" then output ds_resid;
15231 +       if _TYPE_="ACTUAL" then output ds_act;
15232 +       if _TYPE_="&lowerBound" then output ds_lower;
15233 +       if _TYPE_="&upperBound" then output ds_upper;
15234 +       if _TYPE_="STD" then output ds_std;
15235 +  run;
15237 +  data &outdata;
15238 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
15239 +       by &tsidVar &timeid;
15240 +       label  FORECAST = "Forecast";
15241 +       label  ACTUAL = "Actual";
15242 +       label  RESIDUAL = "Residual";
15243 +       label  LBOUND = "Lower Bound";
15244 +       label  UBOUND = "Upper Bound";
15245 +       label   STD = "Standard Deviation";
15246 +  run;
15247 +%mend EM_TSESM_CreateOutFor;
15250 +%macro EM_TSESM_CreateOutExpand(indata=,
15251 +                       target=,
15252 +                       timeid=,
15253 +                       tsidVar=,
15254 +                       percent=,
15255 +                       outlower=,
15256 +                       outupper=,
15257 +                       outdata=);
15259 +  %let lowerBound = L&percent;
15260 +  %let upperBound = U&percent;
15262 +  /*proc print data=&indata(obs=200);
15263 +  run;
15264 +  */
15266 +  data ds_fore(drop=&target)
15267 +       ds_lower(drop=&target)
15268 +       ds_upper(drop=&target)
15269 +       ds_act;
15270 +     set &indata;
15271 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
15272 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
15273 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
15274 +       if _TYPE_="ACTUAL" then output ds_act;
15275 +  run;
15277 +  /*
15278 +  proc print data = ds_fore;
15279 +  proc print data=ds_act;
15280 +  run;
15281 +  */
15282 +  data &outdata;
15283 +       merge ds_act ds_fore;
15284 +       by &tsidVar &timeid;
15285 +  run;
15287 +  data &outlower;
15288 +       merge ds_act ds_lower;
15289 +       by &tsidVar &timeid;
15290 +  run;
15292 +  data &outupper;
15293 +       merge ds_act ds_upper;
15294 +       by &tsidVar &timeid;
15295 +  run;
15296 +  /*
15297 +  proc print data=&outdata(obs=300);
15298 +  proc print data=&outlower(obs=300);
15299 +  proc print data=&outupper(obs=300);
15300 +  run;
15301 +  */
15302 +%mend EM_TSESM_CreateOutExpand;
15306 +%macro EM_TSESM_MakeOutClus(indata=,
15307 +                   target=,
15308 +                   timeid=,
15309 +                   tsidVar=,
15310 +                   percent=,
15311 +                   outlower=,
15312 +                   outupper=,
15313 +                   outdata=);
15316 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15318 +  data &outdata(rename=(_NAME_ =_NAMEID_));
15319 +       set &indata;
15320 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
15321 +  run;
15323 +  %let dsid=%sysfunc(open(&outdata));
15324 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
15325 +  %let dsid=%sysfunc(close(&dsid));
15327 +  %if &vn_name > 0 %then %do;
15328 +      data &outdata(drop=_NAMEID_);
15329 +           merge &EM_USER_TSIDMAP &outdata;
15330 +           by _TSID_;
15331 +      run;
15332 +  %end;
15333 +  %else %do;
15334 +      proc sort data= &outdata; by _NAMEID_;
15335 +      run;
15336 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
15337 +      run;
15338 +      data &outdata(drop=_NAMEID_);
15339 +           merge &EM_USER_TSIDMAP &outdata;
15340 +           by _NAMEID_;
15341 +      run;
15342 +  %end;
15344 +%mend EM_TSESM_MakeOutClus;
15347 +%macro EM_TSESM_CreateOutEst(indata=,
15348 +                    target=,
15349 +                    timeid=,
15350 +                    outdata=);
15352 +%mend EM_TSESM_CreateOutEst;
15355 +%macro EM_TSESM_Best_Forecast(indata=,
15356 +                method=,
15357 +                timeinterval=,
15358 +                timeid= ,
15359 +                target= ,
15360 +                tsidvar=,
15361 +                lead=,
15362 +                back=,
15363 +                startsum=,
15364 +                accumulate=,
15365 +                seasonality=,
15366 +                alpha=,
15367 +                criterion=,
15368 +                extendedvalue=,
15369 +                outest = ,
15370 +                outdata = ,
15371 +                outfor = ,
15372 +                outstat = ,
15373 +                outsum=
15374 +   );
15376 +   %let _indata = &indata;
15378 +   %if &tsidvar eq _SEGMENT_ %then %do;
15379 +       proc sort data=&indata out=_tmpdata;
15380 +            by  &tsidvar %EM_CROSSID &timeid ;
15381 +       run;
15382 +       proc timeseries  data =_tmpdata out=_tmpdata;
15383 +            by  &tsidvar %EM_CROSSID ;
15384 +            id &timeid interval=&timeinterval accumulate=&accumulate;
15385 +            var &target / ;
15386 +       run;
15387 +       %let _indata = _tmpdata;
15388 +   %end;
15390 +   %let n_model = 0;
15392 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
15394 +       %let n_model = %eval(&n_model+1);
15396 +       %let _ds_out =_out&n_model;
15397 +       %let _ds_outest =_outest&n_model;
15398 +       %let _ds_outfor =_outfor&n_model;
15399 +       %let _ds_outstat =_outstat&n_model;
15400 +       %let _ds_outsum=_outsum&n_model;
15402 +       %EM_TSESM_ESM(method=SIMPLE,
15403 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15404 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15405 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15406 +        );
15408 +   %end;
15409 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
15411 +       %let n_model = %eval(&n_model+1);
15413 +       %let _ds_out =_out&n_model;
15414 +       %let _ds_outest =_outest&n_model;
15415 +       %let _ds_outfor =_outfor&n_model;
15416 +       %let _ds_outstat =_outstat&n_model;
15417 +       %let _ds_outsum=_outsum&n_model;
15419 +       %EM_TSESM_ESM(method=DOUBLE,
15420 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15421 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15422 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15423 +       );
15424 +   %end;
15426 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
15428 +       %let n_model = %eval(&n_model+1);
15429 +       %let _ds_out =_out&n_model;
15430 +       %let _ds_outest =_outest&n_model;
15431 +       %let _ds_outfor =_outfor&n_model;
15432 +       %let _ds_outstat =_outstat&n_model;
15433 +       %let _ds_outsum=_outsum&n_model;
15435 +       %EM_TSESM_ESM(method=LINEAR,
15436 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15437 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15438 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15439 +        );
15440 +   %end;
15442 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
15444 +       %let n_model = %eval(&n_model+1);
15446 +       %let _ds_out =_out&n_model;
15447 +       %let _ds_outest =_outest&n_model;
15448 +       %let _ds_outfor =_outfor&n_model;
15449 +       %let _ds_outstat =_outstat&n_model;
15450 +       %let _ds_outsum=_outsum&n_model;
15452 +       %EM_TSESM_ESM(method=DAMPTREND,
15453 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15454 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15455 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15456 +            );
15457 +   %end;
15458 +   /*------- Seasonal model ------*/
15460 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
15462 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
15464 +       %let n_model = %eval(&n_model+1);
15466 +       %let _ds_out =_out&n_model;
15467 +       %let _ds_outest =_outest&n_model;
15468 +       %let _ds_outfor =_outfor&n_model;
15469 +       %let _ds_outstat =_outstat&n_model;
15470 +       %let _ds_outsum=_outsum&n_model;
15472 +       %EM_TSESM_ESM(method=WINTERS,
15473 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15474 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15475 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15476 +        );
15477 +   %end;
15479 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
15481 +       %let n_model = %eval(&n_model+1);
15483 +       %let _ds_out =_out&n_model;
15484 +       %let _ds_outest =_outest&n_model;
15485 +       %let _ds_outfor =_outfor&n_model;
15486 +       %let _ds_outstat =_outstat&n_model;
15487 +       %let _ds_outsum=_outsum&n_model;
15489 +       %EM_TSESM_ESM(method=ADDSEASONAL,
15490 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15491 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15492 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15493 +       );
15494 +   %end;
15496 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
15498 +       %let n_model = %eval(&n_model+1);
15500 +       %let _ds_out =_out&n_model;
15501 +       %let _ds_outest =_outest&n_model;
15502 +       %let _ds_outfor =_outfor&n_model;
15503 +       %let _ds_outstat =_outstat&n_model;
15504 +       %let _ds_outsum=_outsum&n_model;
15506 +       %EM_TSESM_ESM(method=MULTSEASONAL,
15507 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15508 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15509 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15510 +       );
15511 +   %end;
15513 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
15515 +       %let n_model = %eval(&n_model+1);
15517 +       %let _ds_out =_out&n_model;
15518 +       %let _ds_outest =_outest&n_model;
15519 +       %let _ds_outfor =_outfor&n_model;
15520 +       %let _ds_outstat =_outstat&n_model;
15521 +       %let _ds_outsum=_outsum&n_model;
15523 +       %EM_TSESM_ESM(method=ADDWINTERS,
15524 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15525 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15526 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15527 +            );
15528 +   %end;
15531 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
15532 +   /*-------- end of seasonal model  ------------------------------------------------------*/
15534 +   %if &n_model eq 0 %then %do;
15536 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
15537 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
15538 +   %end;
15539 +   %else %do;
15540 +         %EM_TSESM_BestModelSel(crit=&criterion,
15541 +                               n_mdl=&n_model,
15542 +                               tsidvar=&tsidvar,
15543 +                               timeid=&timeid,
15544 +                               out=&outdata,
15545 +                               outest=&outest,
15546 +                               outfor =&outfor,
15547 +                               outstat=&outstat,
15548 +                               outsum=&outsum
15549 +                  );
15550 +   %end;
15552 +%mend EM_TSESM_Best_Forecast;
15555 +%macro EM_TSESM_ESM(method= ,
15556 +           timeinterval=,
15557 +           timeid= ,
15558 +           target= ,
15559 +           tsidvar=,
15560 +           lead=,
15561 +           back=,
15562 +           startsum=,
15563 +           accumulate=,
15564 +           seasonality=,
15565 +           alpha=,
15566 +           out= ,
15567 +           outest= ,
15568 +           outfor= ,
15569 +           outstat= ,
15570 +           outsum=
15571 +           );
15573 +       proc sort data= &_indata out=_tmpdata;
15574 +            by  &tsidvar %EM_CROSSID &timeid ;
15575 +       run;
15576 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
15578 +       %if &seasonality ne DEFAULT %then %do;
15579 +                     seasonality = &seasonality
15580 +       %end;
15581 +            out=&out
15582 +            outest=&outest
15583 +            outfor =&outfor
15584 +            outstat=&outstat
15585 +            outsum= &outsum
15586 +            ;
15587 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
15589 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15590 +            %if &target ne %then %do;
15591 +            forecast &target   /  model = none alpha=&alpha;
15592 +            %end;
15593 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15594 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
15595 +            %end;
15596 +       %end;
15597 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
15598 +            %if &target ne %then %do;
15599 +            forecast &target /  model =&method alpha=&alpha;
15600 +            %end;
15601 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15602 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
15603 +            %end;
15604 +       %end;
15605 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
15606 +            %if &target ne %then %do;
15607 +            forecast &target   /  model = &method alpha=&alpha;
15608 +            %end;
15609 +            /*
15610 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15611 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
15612 +            %end;
15613 +            */
15614 +       %end;
15616 +       %if &tsidvar ne %then %do;
15617 +        by &tsidvar %EM_CROSSID;
15618 +       %end;
15619 +       run;
15621 +%mend EM_TSESM_ESM;
15625 +%macro EM_TSESM_BestModelSel(crit=,
15626 +                    n_mdl=,
15627 +                    tsidvar=_TSID_,
15628 +                    timeid=MNTH_YR,
15629 +                    out=&_outdata,
15630 +                    outest=&_outest,
15631 +                    outfor =&_outfor,
15632 +                    outstat=&_outstat,
15633 +                    outsum=&_outsum
15634 +    );
15636 +   %let statbls=select *, 1 as mdlID from _outstat1;
15637 +   %let estbls=select *,  1 as mdlID from _outest1;
15638 +   %let fortbls=select *, 1 as mdlID from _outfor1;
15639 +   %let outbls=select *,  1 as mdlID from _out1;
15640 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
15641 +   %do i=2 %to &n_mdl;
15642 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
15643 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
15644 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
15645 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
15646 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
15647 +   %end;
15649 +   %let dsid=%sysfunc(open(_out1));
15650 +   %let vn_tsid = 0;
15652 +   %if &dsid > 0 %then %do;
15653 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15654 +         %let dsid = %sysfunc(close(&dsid));
15655 +   %end;
15657 +   %if &vn_tsid <= 0  %then %do;
15658 +       %let tsidvar=_NAME_;
15659 +   %end;
15661 +  /*
15662 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15663 +     %let tsidvar=_NAME_;
15664 +   %end;
15665 +  */
15667 +   proc sql;
15668 +     create table tsstat as &statbls;
15669 +     create table tsest  as &estbls;
15670 +     create table tsfor  as &fortbls;
15671 +     create table tsout  as &outbls;
15672 +     create table tssum  as &sumtbls;
15673 +   quit;
15675 +    proc sort data=tsstat out=bestmdl;
15676 +        by &tsidvar &crit mdlID;
15677 +    run;
15679 +    * when multiple BEST model found;
15680 +    * use the one with smallest model ID;
15681 +    data bestmdl;
15682 +        set bestmdl;
15683 +        by &tsIDvar;
15684 +        if first.&tsIDVar;
15685 +    run;
15687 +   proc sql;
15688 +      create table bestID as
15689 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
15690 +        from bestmdl,tsest
15691 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
15693 +      create table &outfor
15694 +        as select tsfor.*, _model_, &crit from tsfor, bestID
15695 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15697 +        create table &outstat
15698 +        as select tsstat.*, _model_ from tsstat, bestID
15699 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
15701 +        create table &outest
15702 +        as select tsest.*, &crit from bestmdl, tsest
15703 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
15705 +      create table &outsum
15706 +        as select tssum.*, _model_, &crit from tssum, bestID
15707 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
15709 +      /*
15710 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15711 +        create table &out
15712 +          as select tsout.*, _model_, &crit from tsout, bestID
15713 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15714 +      %end;
15715 +      */
15717 +      %if &tsidvar eq _TSID_ %then %do;
15719 +         create table &out
15720 +          as select tsout.*, _model_, &crit from tsout, bestID
15721 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15723 +      %end;
15724 + run;
15725 +quit;
15727 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
15729 + %if &tsidvar = _NAME_ %then %do;
15730 +      data
15731 +            %let i=1;
15732 +            %do i=1 %to &n_mdl;
15733 +               %let _tmpdsname = _tmpds&i;
15734 +                    &_tmpdsname
15735 +            %end;
15736 +        ;
15737 +         set work.Bestmdl;
15738 +            %let i=1;
15739 +            %do i=1 %to &n_mdl;
15740 +               %let _tmpdsname = _tmpds&i;
15741 +                  if mdlID = &i then output &_tmpdsname;
15742 +            %end;
15743 +      run;
15745 +      data &out;
15746 +           set _out1;
15747 +           keep &timeid %EM_TARGET;
15748 +      run;
15749 +      %let i=1;
15750 +      %do i=1 %to &n_mdl;
15751 +          %let _tmpdsname = _tmpds&i;
15752 +          %let _outdsname = _out&i;
15754 +          data &out;
15755 +               set &out;
15756 +               set &_outdsname(keep=
15757 +               %let dsid=%sysfunc(open(&_tmpdsname));
15758 +               %if &dsid > 0 %then %do;
15759 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
15760 +                  %do %while(^%sysfunc(fetch(&dsid)));
15761 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
15762 +                          &_name
15763 +                  %end;
15764 +                  %let dsid = %sysfunc(close(&dsid));
15765 +               %end;
15766 +               );
15767 +           run;
15768 +       %end;
15770 +%end;
15772 +data &out;
15773 +     set  &out;
15774 +      drop mdlID _MODEL_ &crit;
15775 +data &outest;
15776 +      set  &outest;
15777 +      drop mdlID &crit;
15778 +data &outfor;
15779 +     set &outfor;
15780 +     drop mdlID &crit;
15781 +data &outstat;
15782 +     set &outstat;
15783 +     drop mdlID;
15784 +data &outsum;
15785 +     set &outsum;
15786 +     drop mdlID &crit;
15787 +run;
15789 +%mend EM_TSESM_BestModelSel;
15793 +%macro EM_TSESM_MakeOutlierIndex(indata=,
15794 +                        target=,
15795 +                        timeid=,
15796 +                        outoutlier=,
15797 +                        outlierds=,
15798 +                        outdata=);
15799 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
15800 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
15801 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
15802 +data &outdata;
15803 +     set &indata;
15804 +     length OutlierIndex 8.;
15805 +     length Outlier  $40;
15806 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
15807 +     label  Outlier = "&label_Outlier";
15808 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
15809 +       else  do; OutlierIndex=0; outlier =" "; end; */
15810 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
15811 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
15812 +run;
15814 +data  &outoutlier;
15815 +      set  &outdata;
15816 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
15817 +      if ACTUAL = . then delete;
15818 +run;
15820 +data &outlierds;
15821 +     set &outoutlier;
15822 +     if OUTLIERINDEX = 0 then delete;
15823 +     Drop OUTLIERINDEX;
15824 +run;
15826 +%mend  EM_TSESM_MakeOutlierIndex;
15829 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
15830 +                         inoutlierds=,
15831 +                         target=,
15832 +                         timeid=,
15833 +                         tsidvar=_TSID_,
15834 +                         replace=,
15835 +                         outdata=);
15838 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15841 +%let dsid=%sysfunc(open(&indata));
15842 +%let vn_tsid = 0;
15843 +%if &dsid > 0 %then %do;
15844 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15845 +         %let dsid = %sysfunc(close(&dsid));
15846 +%end;
15848 +%if &vn_tsid <= 0  %then %do;
15849 +    %let tsidvar=_NAME_;
15850 +%end;
15852 +%if &tsidvar = _TSID_ %then %do;
15853 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
15854 + /*    data &outdata;
15855 +          merge &indata &inoutlierds;
15856 +          by _TSID_ &timeid;
15857 +          if OutlierIndex > 0 then
15858 +          %if &replace eq PREDICT %then %do;
15859 +             &target = PREDICT;
15860 +          %end;
15861 +          %else %do;
15862 +             &target = .;
15863 +          %end;
15864 +           Drop Predict _NAME_ OutlierIndex;
15865 +     run;     */
15866 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
15867 +     %if &dsid > 0 %then %do;
15868 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
15869 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15870 +         %let i = 1;
15871 +              %do %while(^%sysfunc(fetch(&dsid)));
15872 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
15873 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
15874 +                  %if &i eq 1 %then %do;
15875 +                      data _tmpoutlier;
15876 +                           set &inoutlierds;
15877 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
15878 +                      run;
15879 +                      data &outdata;
15880 +                           merge &indata _tmpoutlier;
15881 +                           by _TSID_ &timeid ;
15882 +                           if OutlierIndex  > 0 then
15883 +                              %if &replace eq PREDICT %then %do;
15884 +                                &_varname = PREDICT;
15885 +                              %end;
15886 +                              %else %do;
15887 +                                &_varname = .;
15888 +                              %end;
15889 +                            Drop Predict _NAME_  OutlierIndex Outlier;
15890 +                      run;
15891 +                   %end;
15892 +                   %else %do;
15893 +                      data _tmpoutlier;
15894 +                           set &inoutlierds;
15895 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
15896 +                      run;
15897 +                      data &outdata;
15898 +                           merge &outdata _tmpoutlier;
15899 +                           by _TSID_ &timeid ;
15900 +                           if OutlierIndex  > 0 then
15901 +                              %if &replace eq PREDICT %then %do;
15902 +                                &_varname = PREDICT;
15903 +                              %end;
15904 +                              %else %do;
15905 +                                &_varname = .;
15906 +                              %end;
15907 +                           Drop Predict _NAME_  OutlierIndex Outlier;
15908 +                      run;
15909 +                   %end;
15910 +                   %let i = %eval(&i+1);
15912 +              %end;
15913 +           %let dsid = %sysfunc(close(&dsid));
15914 +      %end;
15915 +%end;
15916 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
15918 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
15919 +     %if &dsid > 0 %then %do;
15920 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
15921 +         %let i = 1;
15922 +              %do %while(^%sysfunc(fetch(&dsid)));
15923 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
15924 +                  %if &i eq 1 %then %do;
15925 +                      data _tmpoutlier;
15926 +                           set &inoutlierds;
15927 +                           if _NAME_ ="&_varname"  then output;
15928 +                      run;
15929 +                      data &outdata;
15930 +                           merge &indata _tmpoutlier;
15931 +                           by &timeid;
15932 +                           if OutlierIndex  > 0 then
15933 +                              %if &replace eq PREDICT %then %do;
15934 +                                &_varname = PREDICT;
15935 +                              %end;
15936 +                              %else %do;
15937 +                                &_varname = .;
15938 +                              %end;
15939 +                            Drop Predict _NAME_ OutlierIndex Outlier;
15940 +                      run;
15941 +                   %end;
15942 +                   %else %do;
15943 +                      data _tmpoutlier;
15944 +                           set &inoutlierds;
15945 +                           if _NAME_ ="&_varname"  then output;
15946 +                      run;
15947 +                      data &outdata;
15948 +                           merge &outdata _tmpoutlier;
15949 +                           by &timeid;
15950 +                           if OutlierIndex  > 0 then
15951 +                              %if &replace eq PREDICT %then %do;
15952 +                                &_varname = PREDICT;
15953 +                              %end;
15954 +                              %else %do;
15955 +                                &_varname = .;
15956 +                              %end;
15957 +                           Drop Predict _NAME_ OutlierIndex Outlier;
15958 +                      run;
15959 +                   %end;
15960 +                   %let i = %eval(&i+1);
15962 +              %end;
15963 +           %let dsid = %sysfunc(close(&dsid));
15964 +      %end;
15965 +      %else %do;
15966 +            /* this block is added 09022011*/
15967 +            /* works for wide table in which each time series has a column */
15969 +            proc transpose data=&indata out=_tmpdata1;
15970 +                by &timeID;
15971 +            run;
15973 +            proc sql;
15974 +                create table _tmpdata2 as
15975 +                    select a.*, b.outlierindex, b.outlier, b.predict
15976 +                        from _tmpdata1 as a left join &inoutlierds as b
15977 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
15978 +                        order by a.&timeID, a._name_
15979 +                    ;
15980 +            quit;
15982 +            data _tmpdata2;
15983 +                set _tmpdata2;
15984 +                if outlierindex eq 1 then
15985 +                    if &replace eq PREDICT then col1=predict; else col1=.;
15986 +            run;
15988 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
15989 +                by &timeID;
15990 +                ID _name_;
15991 +                var col1;
15992 +            proc sort data=&inoutlierds out=_tmpoutlier;
15993 +                by &timeID _name_;
15994 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
15995 +                by &timeID;
15996 +                ID _name_;
15997 +                var outlier;
15998 +            run;
16000 +            data &outdata;
16001 +                merge _tmpdata3 _tmpdata4;
16002 +                by &timeID;
16003 +            run;
16004 +      %end;
16005 +%end;
16006 +%mend EM_TSESM_MakeSmoothedOutds;
16008 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
16009 +                  insumdata=&EM_USER_OUTSUM,
16010 +                target=&_targetVar,
16011 +                timeid=&_timeidVar,
16012 +                futurepoint=1,
16013 +                outKLD=&EM_USER_OUTKLD
16014 +                );
16016 +%if &futurepoint > 0 %then %do;
16018 +proc sort data=&indata out=_tmptimeid;
16019 +     by &timeid;
16020 +run;
16022 +data _tmptimeid(keep=&timeid);
16023 +      set _tmptimeid; by &timeid;
16024 +      if first.&timeid then output;
16025 +run;
16027 +%let _targetTime =;
16028 +%let dsid=%sysfunc(open(work._tmptimeid));
16029 +%if &dsid > 0 %then %do;
16030 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
16031 +    %let i = 1;
16032 +    %do %while(^%sysfunc(fetch(&dsid)));
16033 +       %if &i eq &futurepoint %then %do;
16034 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
16035 +       %end;
16036 +       %let i = %eval(&i+1);
16037 +    %end;
16038 +    %let dsid = %sysfunc(close(&dsid));
16039 +%end;
16041 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
16042 +   set &indata;
16043 +   if &timeid eq &_targetTime then output;
16044 +run;
16046 +%end;  /* end of %if &futurepoint > 0 %then %do; */
16047 +%else %do;
16050 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
16051 +   set &insumdata;
16052 +run;
16055 +%end;
16057 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
16059 +/* Merge TSIDMAP  */
16061 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16062 +data &outKLD(rename=(_NAME_ =_NAMEID_));
16063 +       set &outKLD;
16064 +run;
16066 +%let dsid=%sysfunc(open(&outKLD));
16067 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
16068 +%let dsid=%sysfunc(close(&dsid));
16070 +%if &vn_name > 0 %then %do;
16071 +      data &outKLD(drop=_NAMEID_);
16072 +           merge &EM_USER_TSIDMAP &outKLD;
16073 +           by _TSID_;
16074 +      run;
16075 +%end;
16076 +%else %do;
16077 +      proc sort data= &outKLD; by _NAMEID_;
16078 +      run;
16079 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
16080 +      run;
16081 +      data &outKLD(drop=_NAMEID_);
16082 +           merge &EM_USER_TSIDMAP &outKLD;
16083 +           by _NAMEID_;
16084 +      run;
16085 +%end;
16087 +/* delete _tmptimeid  _tmpKLD */
16088 +%Mend  EM_TSESM_MakeOutKLD;
16091 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
16092 +                 target=&_targetVar,
16093 +                 timeid=&_timeidVar,
16094 +                 outdata=&EM_USER_OUTPRED
16095 +                 );
16097 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16098 +%let _EndTime = ;
16099 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16100 +%if &dsid > 0 %then %do;
16101 +    %let vn_end =%sysfunc(varnum(&dsid, END));
16102 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
16103 +    %do %while(^%sysfunc(fetch(&dsid)));
16104 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16105 +       /*--------------------------------------------------------
16106 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
16107 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
16108 +        ---------------------------------------------------------*/
16109 +    %end;
16110 +    %let dsid = %sysfunc(close(&dsid));
16111 +%end;
16113 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
16114 +     set &indata;
16115 +     if &timeid > &_EndTime then output;
16116 +run;
16117 +%Mend  EM_TSESM_MakeOutPred;
16120 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
16122 +%let std_x = ;
16123 +%let mu_y = ;
16125 +%let dsid=%sysfunc(open(&indata));
16126 +%if &dsid > 0 %then %do;
16127 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
16128 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
16129 +    %let i=1;
16130 +    %do %while(^%sysfunc(fetch(&dsid)));
16131 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
16132 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
16133 +        %let _tsid = _TSID&i.;
16134 +        /* create new data set */
16135 +            %if &i = 1 %then %do;
16136 +            data _tmpindata;
16137 +                set &indata;
16138 +                  mu_x = &_pred;
16139 +                  std_x = &_std;
16140 +                  rename predict = mu_y;
16141 +                  rename std = std_y;
16142 +            run;
16143 +        data _tmpout;
16144 +                 set _tmpindata;
16145 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
16146 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
16147 +             &_tsid= (KLD1+KLD2)/2;
16148 +             if &_tsid < 0 then &_tsid = 0;
16149 +                   drop KLD1 KLD2;
16150 +         run;
16151 +             %end;
16152 +         %else %do;
16153 +         data _tmpindata;
16154 +                  set _tmpout;
16155 +                  mu_x = &_pred;
16156 +                  std_x = &_std;
16158 +             run;
16159 +         data _tmpout;
16160 +                 set _tmpindata;
16161 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
16162 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
16163 +             &_tsid= (KLD1+KLD2)/2;
16164 +             if &_tsid < 0 then &_tsid = 0;
16165 +                   drop KLD1 KLD2;
16166 +         run;
16168 +         %end;
16169 +             %let i = %eval(&i+1);
16171 +    %end;
16172 +    %let dsid = %sysfunc(close(&dsid));
16173 +    data &outdata;
16174 +         set _tmpout;
16175 +         drop mu_x mu_y std_x std_y;
16176 +    run;
16177 +%end;
16178 +%mend EM_TSESM_KLD;
16181 +%macro EM_TSESM_MakeOutClusInput(indata=,
16182 +                   target=,
16183 +                   timeid=,
16184 +                   tsidVar=,
16185 +                   percent=,
16186 +                   outlower=,
16187 +                   outupper=,
16188 +                   esmmethod=,
16189 +                   criterion=,
16190 +                   outdata=);
16192 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16194 +  data &outdata(rename=(_NAME_ =_NAMEID_));
16195 +       set &indata;
16196 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
16197 +  %if &esmmethod eq BEST %then %do;
16198 +      mdlID _MODEL_ &criterion
16200 +  %end;
16201 +  ;
16202 +  run;
16204 +  %let dsid=%sysfunc(open(&outdata));
16205 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
16206 +  %let dsid=%sysfunc(close(&dsid));
16208 +  %if &vn_name > 0 %then %do;
16209 +      proc sort data= &outdata; by _TSID_;
16210 +      run;
16211 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
16212 +      run;
16214 +      data &outdata(drop=_NAMEID_);
16215 +           merge &EM_USER_TSIDMAP &outdata;
16216 +           by _TSID_;
16217 +      run;
16218 +  %end;
16219 +  %else %do;
16220 +      proc sort data= &outdata; by _NAMEID_;
16221 +      run;
16222 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
16223 +      run;
16224 +      data &outdata(drop=_NAMEID_);
16225 +           merge &EM_USER_TSIDMAP &outdata;
16226 +           by _NAMEID_;
16227 +      run;
16228 +  %end;
16230 +%mend EM_TSESM_MakeOutClusInput;
16232 +%macro EM_TSESM_MakeOutSimInput(indata=,
16233 +                   inoutfor=,
16234 +                   target=,
16235 +                   timeid=,
16236 +                   tsidVar=,
16237 +                   esmmethod=,
16238 +                   criterion=,
16239 +                   outdata=);
16242 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16243 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16245 +   %let _EndTime = ;
16246 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
16247 +   %if &dsid > 0 %then %do;
16248 +   %let vn_end =%sysfunc(varnum(&dsid, END));
16249 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
16250 +   %do %while(^%sysfunc(fetch(&dsid)));
16251 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16252 +   %end;
16253 +   %let dsid = %sysfunc(close(&dsid));
16254 +   %end;
16256 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
16257 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
16259 +   data _out1;
16260 +       set &indata;
16261 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
16262 +           %tsesm_crossid
16263 +   %if &esmmethod eq BEST %then %do;
16264 +      mdlID _MODEL_ &criterion
16265 +   %end;
16266 +   ;
16267 +   run;
16269 +    %let dsid=%sysfunc(open(work._out1));
16270 +    %if &dsid > 0 %then %do;
16271 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
16272 +      %let dsid = %sysfunc(close(&dsid));
16273 +    %end;
16275 +    /*
16276 +    proc print data=_out1(obs=10);
16277 +    run;
16278 +    */
16279 +    %let _existtsid = Y;
16280 +    %if (&vn_tsid = 0)  %then %do;
16281 +    %let _existtsid = N;
16282 +    %goto NO_TSID_SIMINPUT;
16283 +    %end;
16285 +    data _out1;
16286 +        set _out1;
16287 +        where _name_ = "&target";
16288 +    run;
16289 +    %let target2 = &target._;
16290 +    proc transpose data=_out1 out=_out2 prefix=&target2;
16291 +            id _TSID_  ;
16292 +    run;
16293 +    /*
16294 +    proc print data=_out2(obs=11);
16295 +    run;
16296 +    */
16297 +    data _out2;
16298 +       length _index 8.;
16299 +       set _out2;
16300 +       _index=_N_;
16301 +       drop _NAME_ _LABEL_;
16302 +    run;
16305 +   data _out3;
16306 +       length _index 8.;
16307 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
16308 +         _index =_N_;
16309 +        keep &timeid _index;
16311 +   run;
16312 +   /*
16313 +   proc print data=_out2(obs=12);
16314 +   proc print data =_out3(obs=13);
16315 +   run;
16316 +   */
16317 +   data &outdata(drop=_index);
16318 +        merge _out3 _out2;by _index;
16319 +        run;
16322 +  proc transpose data=&outdata out=_tout;
16323 +     id &timeid;
16324 +   run;
16325 +   data _tout;
16326 +        length _TSID_ 8.;
16327 +        set _tout;
16328 +        rename _NAME_= _NAMEID_;
16329 +        _TSID_ = _N_;
16330 +        label _NAME_ = "NAMEID";
16331 +        keep _NAME_ _TSID_;
16333 +   run;
16335 +   data &EM_USER_TSIDMAP;
16336 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
16337 +   run;
16338 +   /*
16339 +   proc print data=_tout(obs=14);
16340 +   run;
16341 +   */
16342 +   proc datasets lib=work nolist;
16343 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
16344 +   run;
16347 +   %NO_TSID_SIMINPUT:
16348 +   %if  &_existtsid eq N %then %do;
16349 +   data &outdata;
16350 +        set &inoutfor(where=(&timeid > &_EndTime));
16351 +   run;
16352 +   %end;
16355 +%mend EM_TSESM_MakeOutSimInput;
16358 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
16359 +%do i=1 %to &nwherevalue;
16360 +     %if &i = 1 %then %do;
16361 +        data &outdata(drop = &wherevar);
16362 +             set &indata;
16363 +               if &wherevar= &i;
16364 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
16365 +               %else %let newname = &wherevar_&i;
16366 +                rename  &targetvar= &newname;
16367 +                   label &targetvar ="&targetvar._&i";
16368 +           run;
16369 +       %end;
16370 +       %else %do;
16371 +        data _tmp_out(drop = &wherevar);
16372 +             set &indata;
16373 +               if &wherevar= &i;
16374 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
16375 +               %else %let newname = &wherevar_&i;
16376 +                rename  &targetvar= &newname;
16377 +                   label &targetvar ="&targetvar._&i";
16378 +           run;
16379 +             data &outdata;
16380 +                  merge &outdata  _tmp_out; by &timeid;
16381 +         run;
16382 +       %end;
16383 +%end;
16385 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
16387 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
16389 +/*
16390 +       MACRO: TS Utility macros
16392 +       PURPOSE: TS Utility macros
16393 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
16395 +       HISTORY:
16396 +       NOTE:
16398 +*/
16400 +/*
16401 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
16402 +                          timeid=, timeformat=, timeinformat=);
16403 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
16405 +    %do;
16406 +    %let m_data      = &data;
16407 +    %let m_decdata   = &decdata;
16408 +    %let m_decmeta   = &decmeta;
16409 +    %let m_cmeta     = &cmeta;
16410 +    %let m_outfile   = &outfile;
16411 +    %let m_crossid   = &crossid;
16412 +    %let m_timeid    = &timeid;
16413 +    %let m_timeformat    = &timeformat;
16414 +    %let m_timeinformat    = &timeinformat;
16415 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
16416 +  %end;
16417 +%mend EM_TS_CreateTsMetaDs;
16418 +*/
16419 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
16420 +proc sql;
16421 +      create table _tmp_inds
16422 +      as select distinct &timeid from  &indata;
16423 +quit;
16424 +run;
16425 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
16426 +  id &timeid
16427 +%if &timeinterval ne %then %do;
16428 +    %if &timeformattype eq DATE %then %do;
16429 +        interval=&timeinterval
16430 +    %end;
16431 +    %else %if &timeformattype eq DATETIME  %then %do;
16432 +        %let dttimeinterval= DT&timeinterval;
16433 +         interval=&dttimeinterval
16434 +    %end;
16435 +%end;
16436 +;
16437 +run;
16439 +data &outds;
16440 +     set _tmp_tsmeta;
16441 +     format START &timeformat;
16442 +     format END &timeformat;
16443 +     length APPLY_START_END $8;
16444 +     APPLY_START_END ="No";
16445 +     FORMAT = "&timeformat";
16446 +     ROLE ="TIMEID";
16447 +     rename TIMEID = NAME;
16448 +     rename SEASONALITY= LengthOfCycle;
16449 +     rename INTERVAL = TIMEINTERVAL ;
16450 +     rename FORMAT = TIMEFORMAT;
16451 +     output;
16452 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
16453 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
16454 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
16455 +run;
16457 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
16458 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
16460 +%mend EM_TS_CreateTSMetaData;
16464 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
16466 +/* if updated = Y it will pass the TSMETA created by just the previous node */
16468 +%let _tsmetads = ;
16470 +%if &updated = Y %then %do;
16471 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
16472 +%if %sysfunc(exist(&_tsmetads)) %then %do;
16473 +%goto endline;
16474 +%end;
16475 +%end;
16477 +%if &eminfodata eq %then %do;
16478 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
16479 +    data &EM_DATA_EMINFO;
16480 +         set &EM_IMPORT_DATA_EMINFO;
16481 +    run;
16482 +%end;
16483 +%else %do;
16484 +    %let dsid=%sysfunc(open(&eminfodata));
16485 +    data &EM_DATA_EMINFO;
16486 +         set &eminfodata;
16487 +    run;
16488 +%end;
16489 +%if &dsid > 0 %then %do;
16490 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
16491 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
16492 +    %do %while(^ %sysfunc(fetch(&dsid)));
16493 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
16494 +         %if &_key eq TSMETA %then %do;
16495 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
16496 +         %end;
16497 +    %end;
16498 +    %let dsid = %sysfunc(close(&dsid));
16499 +%end; /* the end of %if &dsid > 0 %then %do; */
16501 +%endline:
16503 +%if &_tsmetads ne %then %do;
16504 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
16505 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16506 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
16507 +         data &EM_USER_TSMETA;
16508 +                   set &_tsmetads;
16509 +         run;
16510 +    %end;
16511 +%end;
16513 +*proc print data=&EM_DATA_EMINFO;
16514 +*proc print data=&EM_IMPORT_DATA_EMINFO;
16515 +*run;
16516 +%MEND EM_TS_GETTSMETA;
16519 +/*
16520 +%macro EM_GETTSMETAVARS(TimeInterval=);
16521 +%global &TimeInterval;
16522 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16523 +%if &dsid > 0 %then %do;
16524 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
16525 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
16526 +%do %while(^ %sysfunc(fetch(&dsid)));
16527 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16528 +     %if &_role eq TIMEID %then %do;
16529 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
16530 +     %end;
16531 +%end;
16532 +%let dsid = %sysfunc(close(&dsid));
16533 +%end;
16534 +%MEND EM_GETTSMETAVARS;
16535 +*/
16536 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
16537 +%global &TimeInterval;
16538 +%global &TimeId;
16539 +%global &EndTime;
16540 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16541 +proc print data=&EM_USER_TSMETA;
16542 +run;
16543 +%if &dsid > 0 %then %do;
16544 +%if &TimeInterval ne %then %do;
16545 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
16546 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16547 +    %do %while(^ %sysfunc(fetch(&dsid)));
16548 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16549 +        %if &_role eq TIMEID %then %do;
16550 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
16551 +        %end;
16552 +     %end;
16553 +%end;
16554 +%if &TimeId ne %then %do;
16555 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
16556 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16557 +    %do %while(^ %sysfunc(fetch(&dsid)));
16558 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16559 +        %if &_role eq TIMEID %then %do;
16560 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
16561 +        %end;
16562 +    %end;
16563 +%end;
16565 +%if &EndTime ne %then %do;
16566 +    %let vn_end =%sysfunc(varnum(&dsid, END));
16567 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16568 +    %do %while(^ %sysfunc(fetch(&dsid)));
16569 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16570 +        %if &_role eq TIMEID %then %do;
16571 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16572 +        %end;
16573 +     %end;
16574 +%end;
16575 +%let dsid = %sysfunc(close(&dsid));
16576 +%end;
16577 +%MEND EM_TS_GETTSMETAVARS;
16581 +/*------------------------------------------------------------------
16583 +      Macro EM_GETTSIDMAP
16585 +------------------------------------------------------------------+*/
16588 +%macro EM_TS_GETTSIDMAP(updated=);
16590 +%let _tsidmap = ;
16592 +%if &updated = Y %then %do;
16593 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
16594 +%if %sysfunc(exist(&_tsidmap)) %then %do;
16595 +%goto endline;
16596 +%end;
16597 +%end;
16599 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
16600 +%if &dsid > 0 %then %do;
16601 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
16602 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
16603 +%do %while(^ %sysfunc(fetch(&dsid)));
16604 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
16605 +     %if &_key eq TSIDMAP %then %do;
16606 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
16607 +     %end;
16608 +%end;
16610 +%let dsid = %sysfunc(close(&dsid));
16611 +%end;
16613 +%endline:
16615 +%if &_tsidmap ne %then %do;
16617 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
16618 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16620 +%if %sysfunc(exist(&_tsidmap)) %then %do;
16621 +         data &EM_USER_TSIDMAP;
16622 +               set &_tsidmap;
16623 +         run;
16624 +    %end;
16625 +%end;
16626 +%MEND EM_TS_GETTSIDMAP;
16628 +/*------------------------------------------------------------------*/
16633 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
16634 +%global &value;
16637 +%let dsid = %sysfunc(open(&data));
16638 +%if &dsid > 0 %then %do;
16639 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
16640 +    %if &vn_var < 1 %then %do;
16641 +        %let &value = 0;
16642 +        %let dsid = %sysfunc(close(&dsid));
16643 +        %goto endline;
16644 +    %end;
16645 +%let dsid = %sysfunc(close(&dsid));
16646 +%end;
16648 +%let _tmp=_tmpDS;
16649 +proc means data=&data &stat;
16650 +     var &var;
16651 +     output out=&_tmp;
16652 +run;
16654 +%let dsid = %sysfunc(open(&_tmp));
16655 +%if &dsid > 0 %then %do;
16656 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
16657 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
16658 +     %do %while(^%sysfunc(fetch(&dsid)));
16659 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
16660 +         %if &_stat eq &stat %then %do;
16661 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
16662 +          %end;
16663 +      %end;
16664 +%let dsid = %sysfunc(close(&dsid));
16665 +%end;
16666 +proc datasets lib=work nolist;
16667 + delete &_tmp;
16668 +run;
16669 +%endline:
16670 +%MEND EM_TS_GET_STAT;
16673 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
16674 +%global &format;
16675 +%global &informat;
16676 +%let dsid = %sysfunc(open(&data));
16677 +%if &dsid > 0 %then %do;
16678 +%let vn_var =%sysfunc(varnum(&dsid, &var));
16679 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
16680 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
16681 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
16682 +%end;
16683 +%let dsid = %sysfunc(close(&dsid));
16684 +%end;
16685 +%MEND EM_TS_GET_VAR_FORMAT;
16687 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
16688 +      %if &lib eq %then %let lib=work;
16689 +       proc datasets lib=&lib nolist;
16690 +              delete &dsname;
16691 +       run;
16692 +%Mend  EM_TS_DELETE_DATA;
16695 +%macro EM_TS_GetNObs(inds=, nobs=);
16696 +    %global &nobs;
16697 +    %let &nobs=0;
16698 +    data _null_;
16699 +        set &inds end=eof;
16700 +        if eof then call symput("&nobs", _N_);
16701 +    run;
16702 +    quit;
16704 +    /*
16705 +    %let dsid=%sysfunc(open(&outdata));
16706 +    %if dsid > 0 %then %do;
16707 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
16708 +        %let dsid = %sysfunc(close(&dsid));
16709 +     %end;
16710 +    */
16711 +%mend  EM_TS_GetNObs;
16714 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
16715 +%global &time1;
16716 +%global &time2;
16717 +%if &default = Y %then %do;
16718 +   data _null_;
16719 +        set &data end=eof;
16720 +        if _N_ = 1 then  call symput("&time1", DATE);
16721 +        if eof then call symput("&time2", DATE);
16722 +    run;%end;
16723 +%else %do;
16724 +    %let dsid = %sysfunc(open(&data));
16725 +    %if &dsid > 0 %then %do;
16726 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
16727 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
16728 +        %do %while(^%sysfunc(fetch(&dsid)));
16729 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
16730 +             %if &_index eq 1 %then %do;
16731 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
16732 +             %end;
16733 +             %if &_index eq 2 %then %do;
16734 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
16735 +             %end;
16736 +        %end;
16737 +    %let dsid = %sysfunc(close(&dsid));
16738 +    %end;
16739 +%end;
16741 +%MEND EM_TS_GET_TIME_VALUES;
16743 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
16744 +%global &exist;
16745 + %let &exist = N;
16746 +%let dsid = %sysfunc(open(&data));
16747 +%if &dsid > 0 %then %do;
16748 +%let vn_var =%sysfunc(varnum(&dsid, &var));
16749 +%if &vn_var > 0 %then %do;
16750 +    %let &exist = Y;
16751 +%end;
16752 +%let dsid = %sysfunc(close(&dsid));
16753 +%end;
16754 +%MEND EM_TS_GET_VAR_EXIST;
16757 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
16758 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
16759 +      set &intreedata;
16760 +        LENGTH NodeType $32;
16761 +      if _PARENT_ eq " " then delete;
16762 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
16763 +        else NodeType = "CLUSTER";
16764 +        LinkID = _N_;
16765 +run;
16766 +%Mend EM_TS_MakeConstellPlotData;
16771 +%macro EM_TS_CreateIDMap(
16772 +/*-------------------------------------------------------------------------*/
16773 +/*---   Written by Xiangxiang Meng                                         */
16774 +/*-------------------------------------------------------------------------*/
16775 +inDS          =,      /* imported data set in TS data mining               */
16776 +outIDMap      =,      /* output data set of TS ID map                      */
16777 +outDS         =,      /* output data set of TS and TS ID merged            */
16778 +variableSet   =,      /* EM variable set                                   */
16779 +TSIDbyCrossID =Y,
16780 +inEM          =Y
16781 +/*-------------------------------------------------------------------------*/
16782 +);
16784 +%global EM_TS_ERR;
16785 +%let EM_TS_ERR = 0;
16787 +%if &inEM eq Y %then %do;
16788 +    %let num_crossIDVar = &EM_NUM_CROSSID;
16789 +    proc sql noprint;
16790 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
16791 +    quit;
16792 +%end;
16793 +%else %do;
16794 +    proc sql noprint;
16795 +         select count(*) into :num_crossIDVar from &variableSet
16796 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16797 +         ;
16798 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
16799 +         ;
16800 +    quit;
16801 +    %let num_crossIDVar=&num_crossIDVar;
16802 +%end;
16804 +* see if _TSID_ exists;
16806 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
16807 +run;
16809 +proc sql noprint;
16810 +    select count(*) into :has_TSID
16811 +        from _emtscm_contents
16812 +        where upcase(strip(name)) eq '_TSID_'
16813 +    ;
16814 +quit;
16816 +/*-------------------------------------------------------------------------*/
16817 +* Creating TSID map..;
16818 +/*-------------------------------------------------------------------------*/
16820 +%if (&num_crossIDVar gt 0) %then %do;
16822 +    data _emtscm_tmpIDMap;
16823 +        set &variableSet;
16824 +        where  (upcase(strip(level)) eq 'INTERVAL')
16825 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
16826 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
16827 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
16828 +          );
16829 +        _emts_dummy=1;
16830 +        keep name label role _emts_dummy;
16831 +    run;
16833 +    proc sql noprint;
16834 +        * create a string of crossID variable like A,B,C,D..;
16835 +        select distinct name into :crossIDVar separated by ','
16836 +            from &variableSet
16837 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16838 +            order by name
16839 +        ;
16840 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
16841 +            from &variableSet
16842 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16843 +            order by name
16844 +        ;
16845 +        * create the TSID map data set;
16846 +        create table _emtscm_tmp1 as
16847 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
16848 +        ;
16849 +        * create a level list of cross ID variables and time series variables;
16850 +        create table &outIDMap as
16851 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
16852 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
16853 +            where a._emts_dummy eq b._emts_dummy
16854 +            order by a.name, &crossIDVar
16855 +        ;
16856 +    quit;
16858 +    %if &TSIDbyCrossID = Y %then %do;
16859 +        * create unique TSID only by Cross ID;
16860 +        data &outIDMap;
16861 +            length _TSID_ 8;
16862 +            set &outIDMap;
16863 +            by _NAMEID_;
16864 +            if first._NAMEID_
16865 +                then _TSID_=1;
16866 +                else _TSID_+1;
16867 +        run;
16868 +        %if "&outDS" ne "" %then %do;
16869 +            * merge TSID into &inDS;
16870 +            proc sql noprint;
16871 +                create table &outDS as
16872 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
16873 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
16874 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
16875 +                        where %do i = 1 %to &num_crossIDVar;
16876 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
16877 +                              %end;
16878 +                             b._TSID_ is not missing
16879 +                    order by b._TSID_, a.&timeIDVar
16880 +                ;
16881 +            quit;
16882 +        %end;
16883 +    %end;
16884 +    %else %do;
16885 +        * create unique TSID by Cross ID and _NAMEID_;
16886 +        data &outIDMap;
16887 +            length _TSID_ 8;
16888 +            set &outIDMap;
16889 +            _TSID_=_n_;
16890 +        run;
16891 +        %if "&outDS" ne "" %then %do;
16892 +            *no merge in this output;
16893 +            data &outDS;
16894 +                set &inDS;
16895 +            run;
16896 +        %end;
16897 +    %end;
16899 +    proc sort data=&outIDMap;
16900 +        by _NAMEID_ _TSID_;
16901 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
16902 +        format _TSID_ best12. _NAMEID2_ $40.;
16903 +        set &outIDMap;
16904 +        by _NAMEID_;
16905 +        if first._NAMEID_
16906 +            then _emts_ind=1;
16907 +            else _emts_ind+1;
16908 +        drop _emts_ind;
16909 +        rename _NAMEID_=_VARNAME_;
16910 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
16911 +        if _labelID_ eq ' '
16912 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
16913 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
16914 +    run;
16916 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
16918 +%end;
16919 +%else %do; /* if no crossid's the nameid needs to be created */
16921 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
16922 +        length _TSID_ 8;
16923 +        set &variableSet;
16924 +        where  (upcase(strip(level)) eq 'INTERVAL')
16925 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
16926 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
16927 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
16928 +          );
16929 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
16930 +        rename ROLE = _ROLE_;
16931 +        _NAMEID_=strip(name);
16932 +        _VARNAME_=strip(name);
16933 +        if label eq ' '
16934 +            then _LABELID_ = strip(name);
16935 +            else _LABELID_ = strip(label);
16936 +        _TSID_=_n_;
16937 +    run;
16939 +    %if "&outDS" ne "" %then %do;
16940 +        *no merge in this output;
16941 +        data &outDS;
16942 +            set &inDS;
16943 +        run;
16944 +    %end;
16945 +%end;
16947 +data &outIDMap;
16948 +    set &outIDMap;
16949 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
16950 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
16951 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
16952 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
16953 +run;
16955 +proc datasets lib=work nolist;
16956 +    delete _emtscm_:;
16957 +run; quit;
16959 +%mend EM_TS_createIDMap;
16961 +%macro EM_TS_CreateMetaData(
16962 +/*-------------------------------------------------------------------------*/
16963 +  inDS          =,      /* imported data set in TS data mining             */
16964 +  outDS         =,      /* output data set of TS metadata                  */
16965 +  variableSet   =,      /* EM variable set                                 */
16966 +  timeInterval  =,      /* time interval                                   */
16967 +  rc            =       /* return code                                     */
16968 +/*-------------------------------------------------------------------------*/
16969 +);
16971 +%if %eval(
16972 +      &EM_NUM_BINARY_INPUT   +
16973 +      &EM_NUM_ORDINAL_INPUT  +
16974 +      &EM_NUM_NOMINAL_INPUT  +
16975 +      &EM_NUM_BINARY_REJECTED   +
16976 +      &EM_NUM_ORDINAL_REJECTED  +
16977 +      &EM_NUM_NOMINAL_REJECTED  +
16978 +      &EM_NUM_ORDINAL_TARGET  +
16979 +      &EM_NUM_NOMINAL_TARGET +
16980 +      &EM_NUM_BINARY_TARGET
16981 +      ) > 0
16982 +%then %do;
16983 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
16984 +        %put &em_codebar;
16985 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
16986 +        %put &errormsg;
16987 +        %put &em_codebar;
16988 +        %goto ENDLINE;
16989 +%end;
16991 +%global EM_TS_ERR;
16992 +%let EM_TS_ERR = 0;
16994 +%if &timeInterval eq AUTO
16995 +    %then %let timeInterval  = ;
16996 +    %else %let timeInterval  = %upcase(&timeInterval);
16998 +/*-------------------------------------------------------------------------*/
16999 +* check time ID variable;
17000 +/*-------------------------------------------------------------------------*/
17002 +* number of variables in the Variableset with ROLE=TIMEID;
17003 +proc sql noprint;
17004 +    select count(*) into :num_timeID from &variableset
17005 +        where upcase(role) eq 'TIMEID';
17006 +quit;
17008 +/*-------------------------------------------------------------------------*/
17009 +* process only when there is one Time ID, otherwise exception message;
17010 +/*-------------------------------------------------------------------------*/
17012 +%if &num_timeID eq 0 %then %do;
17014 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
17015 +    %let EM_TS_ERR = 11;
17016 +    %put &em_codebar;
17017 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
17018 +    %put &errormsg;
17019 +    %put &em_codebar;
17020 +    %goto tscm_endline;
17022 +%end;
17023 +%else %if &num_timeID gt 1 %then %do;
17025 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
17026 +    %let EM_TS_ERR = 12;
17027 +    %put &em_codebar;
17028 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
17029 +    %put &errormsg;
17030 +    %put &em_codebar;
17031 +    %goto tscm_endline;
17033 +%end;
17034 +%else %do;
17035 +    *** proceed when there is one Time ID;
17037 +    data _null_;
17038 +        set &variableset(where=(upcase(role)='TIMEID'));
17039 +        call symput('timeIDFormat',     strip(format));
17040 +        call symput('timeID',           strip(upcase(name)      ));
17041 +        call symput('timeIDLevel',      strip(upcase(level))     );
17042 +        call symput('timeIDFormatType', strip(upcase(formattype)));
17043 +    run;
17045 +    *** exception message if the time ID is not an interval variable;
17046 +    %if &timeIDLevel ne INTERVAL %then %do;
17047 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
17048 +        %let EM_TS_ERR = 13;
17049 +        %put &em_codebar;
17050 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
17051 +        %put &errormsg;
17052 +        %put &em_codebar;
17053 +        %goto tscm_endline;
17054 +    %end;
17056 +    %if (&timeIDFormatType ne DATETIME) and
17057 +        (&timeIDFormatType ne DATE) and
17058 +        (&timeIDFormatType ne TIME) and
17059 +        (&timeIDFormatType ne USER)
17060 +    %then %do;
17061 +        *** sequential format-type of time ID;
17063 +        %let timeInterval = DAY;
17064 +        %let timeIDFormatType = SEQ;
17066 +        proc sql noprint;
17067 +            create table _emtscm_inds as
17068 +                 select distinct &timeID from &inDS(keep=&timeID)
17069 +                 where &timeID is not missing;
17070 +            select count(*) into :num_nonInteger from _emtscm_inds
17071 +                where &timeID ne int(&timeID);
17072 +        quit;
17074 +        %if &num_nonInteger gt 0 %then %do;
17075 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
17076 +            %let EM_TS_ERR = 14;
17077 +            %put &em_codebar;
17078 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
17079 +            %put &errormsg;
17080 +            %put &em_codebar;
17081 +            %goto tscm_endline;
17082 +        %end;
17083 +    %end;
17084 +    %else %do;
17085 +        *** date, datetime, time format-type of time ID;
17087 +        *** must have a format;
17088 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
17089 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
17090 +            %let EM_TS_ERR = 15;
17091 +            %put &em_codebar;
17092 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
17093 +            %put &errormsg;
17094 +            %put &em_codebar;
17095 +            %goto tscm_endline;
17096 +        %end;
17098 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
17099 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
17100 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
17101 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
17102 +                %let EM_TS_ERR = 16;
17103 +                %put &em_codebar;
17104 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
17105 +                %put &errormsg;
17106 +                %put &em_codebar;
17107 +                %goto tscm_endline;
17108 +            %end;
17109 +        %end;
17111 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
17112 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
17113 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
17114 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
17115 +                %let EM_TS_ERR = 17;
17116 +                %put &em_codebar;
17117 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
17118 +                %put &errormsg;
17119 +                %put &em_codebar;
17120 +                %goto tscm_endline;
17121 +            %end;
17122 +        %end;
17124 +        *** the AUTO function is currently turned off for TIME timeID variable;
17125 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
17126 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
17127 +            %let EM_TS_ERR = 18;
17128 +            %put &em_codebar;
17129 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
17130 +            %put &errormsg;
17131 +            %put &em_codebar;
17132 +            %goto tscm_endline;
17133 +        %end;
17135 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
17136 +            %then %let timeInterval =DT&timeInterval;
17138 +        proc sql noprint;
17139 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
17140 +                where &timeID is not missing;
17141 +        quit;
17142 +    %end;
17144 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
17145 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
17146 +    run;
17148 +    %let hasValidInterval = 0;
17149 +    %let hasLengthOne     = 0;
17151 +    proc sql noprint;
17152 +        create table _emtscm_label as
17153 +            select name,label
17154 +            from dictionary.columns
17155 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
17156 +        ;
17157 +        create table _emtscm_meta2 as
17158 +            select a.*, b.label
17159 +            from _emtscm_meta as a, _emtscm_label as b
17160 +            where upcase(a.timeID) eq upcase(b.name)
17161 +        ;
17162 +    quit;
17164 +    data &outDS;
17165 +        set _emtscm_meta2;
17166 +        format
17167 +            timeformat      $30.
17168 +            role            $10.
17169 +            start           &timeIDformat
17170 +            end             &timeIDformat
17171 +            apply_start_end $8.
17172 +        ;
17173 +        rename
17174 +            timeID      = name
17175 +            seasonality = lengthOfCycle
17176 +            interval    = timeinterval
17177 +        ;
17178 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
17180 +        role            = "TIMEID";
17181 +        apply_start_end = 'N';
17182 +        timeformat      = symget('timeIDformat');
17183 +        timeformattype  = symget('timeIDformatType');
17185 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
17186 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
17187 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
17188 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
17189 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
17190 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
17191 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
17192 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
17193 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
17194 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
17196 +        if timeformattype eq 'SEQ' then do;
17197 +            timeformat='BEST12.';
17198 +            seasonality=1;
17199 +        end;
17201 +        call symput('_tinterval',interval);
17203 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
17205 +        if upcase(timeformattype) eq 'DATE' and
17206 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
17207 +            then call symput('hasValidInterval',1);
17209 +        if upcase(timeformattype) eq 'DATETIME' and
17210 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
17211 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
17212 +            then call symput('hasValidInterval',1);
17214 +        if upcase(timeformattype) eq 'TIME' and
17215 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
17216 +            then call symput('hasValidInterval',1);
17218 +        if upcase(timeformattype) eq 'SEQ'
17219 +            then call symput('hasValidInterval',1);
17221 +        if upcase(timeformattype) eq 'USER'
17222 +            then call symput('hasValidInterval',1);
17224 +        if start eq end
17225 +            then call symput('hasLengthOne',1);
17226 +    run;
17228 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
17230 +    *** detect any missing time interval after running PROC TIMEID;
17231 +    %if &_tinterval eq %then %do;
17232 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
17233 +        %let EM_TS_ERR = 19;
17234 +        %put &em_codebar;
17235 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
17236 +        %put &errormsg;
17237 +        %put &em_codebar;
17238 +        %goto tscm_endline;
17239 +    %end;
17241 +    *** detect any missing time interval after running PROC TIMEID;
17242 +    %if &hasValidInterval eq 0 %then %do;
17243 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
17244 +        %let EM_TS_ERR = 20;
17245 +        %put &em_codebar;
17246 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
17247 +        %put &errormsg;
17248 +        %put &em_codebar;
17249 +        %goto tscm_endline;
17250 +    %end;
17252 +    %if &hasLengthOne eq 1 %then %do;
17253 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
17254 +        %let EM_TS_ERR = 21;
17255 +        %put &em_codebar;
17256 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
17257 +        %put &errormsg;
17258 +        %put &em_codebar;
17259 +        %goto tscm_endline;
17260 +    %end;
17262 +%end;
17264 +%tscm_endline:;
17266 +%mend EM_TS_CreateMetaData;
17269 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
17271 +data _null_;
17272 +    set &tsmeta;
17273 +    call symput('_timeidFormatType', timeformattype);
17274 +    call symput('_timeid', strip(name));
17275 +    call symput('_seqstartnum',strip(put(start,best12.)));
17276 +run;
17278 +proc contents data=&inDS noprint
17279 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
17280 +run; quit;
17282 +data _null_;
17283 +    set _emts_tmpp1;
17284 +    call symput('_timeIDlabel',label);
17285 +run;
17287 +%if &_timeidFormatType eq SEQ
17288 +%then %do;
17289 +    proc sql noprint;
17290 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
17291 +    quit;
17292 +    %let _dummystarttime=&_dummystarttime;
17294 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
17295 +        set &inDS;
17296 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
17297 +        drop &_timeid;
17298 +        label _tsdp_tmpID = "&_timeIDlabel";
17300 +    run;
17301 +%end;
17303 +%mend;
17305 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
17307 +data _null_;
17308 +    set &tsmeta;
17309 +    call symput('_timeidFormatType', timeformattype);
17310 +    call symput('_timeidFormat', timeformat);
17311 +    call symput('_timeid', strip(name));
17312 +    call symput('_timeinterval',strip(upcase(timeinterval)));
17313 +run;
17315 +/* manually change time ID format to a longer enough time format */
17316 +/* because proc timeid returns time5. for second time interval */
17317 +/* which is not long enough for transpose with time unit as seconds */
17318 +%if &_timeinterval eq SECOND
17319 +%then %do;
17320 +    %let _timeIDformat = %str(time8.);
17321 +%end;
17323 +proc contents data=&inDS noprint
17324 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
17325 +run; quit;
17327 +data _null_;
17328 +    set _emts_tmpp1;
17329 +    call symput('_timeIDlabel',label);
17330 +run;
17332 +%if &_timeidFormatType eq TIME
17333 +%then %do;
17334 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
17335 +        set &inDS;
17336 +        _tsdp_tmpID = timepart(&_timeID);
17337 +        format _tsdp_tmpID &_timeidFormat;
17338 +        label  _tsdp_tmpID = "&_timeIDlabel";
17339 +        drop &_timeid;
17340 +    run;
17341 +%end;
17343 +%mend;
17345 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
17347 + proc sql noprint;
17348 +     create table _tmptimetable as
17349 +         select distinct &timeidvar as DATE from &inDS
17350 +         where &timeIDVar is not missing
17351 +         order by &timeIDVar;
17352 + quit;
17354 +%if &compare eq Y %then %do;
17355 +    * compare with the existing time table;
17356 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
17357 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
17358 +    run;
17360 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
17362 +    %if &_diffobs > 0 %then %do; /* create it again */
17363 +        data &outDS(keep=DATE _INDEX_);
17364 +            set _tmptimetable end = _eof_;
17365 +            if _N_ = 1
17366 +                then _INDEX_ = 1;
17367 +                else _INDEX_ = 0;
17368 +            if _eof_ then _INDEX_= 2;
17369 +        run;
17370 +    %end;
17372 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
17373 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
17374 +%end;
17375 +%else %do;
17376 +    * create a new time table directly;
17377 +    data &outDS(keep=DATE _INDEX_);
17378 +        set _tmptimetable end = _eof_;
17379 +        if _N_ = 1
17380 +            then _INDEX_ = 1;
17381 +            else _INDEX_ = 0;
17382 +        if _eof_ then _INDEX_= 2;
17383 +    run;
17385 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
17386 +%end;
17388 +* assign a defult format BEST12. for sequential time ID;
17390 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
17392 +%let _nodatefmt=N;
17394 +data _null_;
17395 +    set _tmpcontents;
17396 +    where upcase(name) eq 'DATE';
17397 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
17398 +run;
17400 +%if "&_nodatefmt" eq "Y" %then %do;
17401 +    data &outDS;
17402 +        set &outDS;
17403 +        format date best12.;
17404 +    run;
17405 +%end;
17407 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
17409 +%mend;
17413 +%macro EM_TS_Transpose(
17414 +/*-------------------------------------------------------------------------*/
17415 +  inDS          =,      /* imported data set in TS data mining             */
17416 +  inIDMap       =,      /* input TS ID map                                 */
17417 +  variableSet   =,      /* variable set                                    */
17418 +  transposeBy   =,      /* byTSID or byTimeID                              */
17419 +  outDS         =,      /* output transposed data set                      */
17420 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
17421 +  inEM          =Y,
17422 +  timePrefix    =_T
17423 +/*-------------------------------------------------------------------------*/
17424 +);
17426 +%let timePrefix = &timePrefix;
17428 +%if  &EM_NUM_CROSSID > 0 %then %do;
17430 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
17431 +    set &inIDMap;
17432 +    drop _NAMEID_;
17433 +    run;
17434 +%let inIDMap=_emtstp_map0;
17436 +%end;
17438 +proc sql noprint;
17439 +    * number of TS Variables to be transposed;
17440 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
17441 +    ;
17442 +    * number of TS Variables to be transposed;
17443 +    select max(_TSID_) into :num_TSID from &inIDMap
17444 +    ;
17445 +    * name list of TS Variables;
17446 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
17447 +        from &inIDMap
17448 +        order by _NAMEID_
17449 +    ;
17450 +    * total number of time series =max(_TSID_)*&num_TSVar;
17451 +    * and the number of digits of this variable is &num_digits;
17452 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
17453 +        from &inIDMap
17454 +    ;
17455 +      * Time ID variable;
17456 +    select name into:timeIDVar from &variableset
17457 +        where upcase(role) eq 'TIMEID'
17458 +    ;
17459 +quit;
17460 +%let num_digits = &num_digits;
17461 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
17463 +/*-------------------------------------------------------------------------*/
17465 +* get number of cross IDs and also the TIME ID variable name;
17466 +%if &inEM eq Y %then %do;
17467 +    %let num_crossIDVar = &EM_NUM_CROSSID;
17468 +    %let crossIDVar     = %EM_CROSSID;
17469 +%end;
17470 +%else %do;
17471 +    proc sql noprint;
17472 +        * number of cross ID;
17473 +        select count(*) into :num_crossIDVar
17474 +            from &variableSet
17475 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17476 +        ;
17477 +        * create a string of crossID variable like A B C D..;
17478 +        select distinct name into :crossIDVar separated by ' '
17479 +            from &variableSet
17480 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17481 +            order by name
17482 +        ;
17483 +    quit;
17484 +    %let num_crossIDVar=&num_crossIDVar;
17485 +%end;
17487 +/*-------------------------------------------------------------------------*/
17489 +%if (&num_crossIDVar gt 0) %then %do;
17491 +    data _emtstp_tmpDat;
17492 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
17493 +        _NAMEID_ = cats("_TS_",_TSID_);
17494 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
17495 +    run;
17497 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
17499 +        * update the ID maps;
17500 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
17501 +            by _NAMEID_ _TSID_;
17502 +        data &outIDMap;
17503 +            set _emtstp_tmpmap;
17504 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
17505 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
17506 +        run;
17508 +        * get the names for the new variables;
17509 +        proc sql noprint;
17510 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
17511 +            ;
17512 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
17513 +            ;
17514 +        quit;
17516 +        * data must be sorted before transposed;
17517 +        proc sort data=_emtstp_tmpDat;
17518 +            by &timeIDvar;
17519 +        run;
17521 +        %do i = 1 %to &num_TSVar;
17522 +            %let i = &i;
17523 +            * transpose one cross-type time series data by TSID;
17524 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
17525 +                id _NAMEID_;
17526 +                by &timeIDVar;
17527 +                var &&&TSVar&i;
17528 +            run;
17529 +        %end;
17531 +        * merge all vertical time series, rename and label them;
17532 +        data &outDS;
17533 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
17534 +            by &timeIDVar;
17535 +            rename
17536 +                %do i = 1 %to &num_TSVar;
17537 +                    %do j = 1 %to &num_TSID;
17538 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
17539 +                        /* %put &i &j &num1 &num_TSID; */
17540 +                        _V_&i._TS_&j = &&&tsname&num1
17541 +                    %end;
17542 +                %end;
17543 +            ;
17544 +            label
17545 +                %do i = 1 %to &num_TSVar;
17546 +                    %do j = 1 %to &num_TSID;
17547 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
17548 +                        /* %put &i &j &num1 &num_TSID; */
17549 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
17550 +                    %end;
17551 +                %end;
17552 +            ;
17553 +        run;
17554 +    %end;
17555 +    %else %do;
17557 +        * update the ID maps;
17558 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
17559 +            by _NAMEID_ _TSID_;
17560 +        data &outIDMap;
17561 +            set _emtstp_tmpmap;
17562 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
17563 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
17564 +        run;
17566 +        proc sql noprint;
17567 +            * get the roles for the new variables;
17568 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
17569 +                from &inIDMap
17570 +                order by _NAMEID_
17571 +            ;
17572 +            * get the length of the time series;
17573 +            select count(distinct &timeIDvar) into :num_T
17574 +                from _emtstp_tmpDat
17575 +            ;
17576 +        quit;
17578 +        * data must be sorted before transposed;
17579 +        proc sort data=_emtstp_tmpDat;
17580 +            by _TSID_ &crossIDVar &timeIDvar;
17581 +        run;
17583 +        %do i = 1 %to &num_TSVar;
17584 +            %let i = &i;
17585 +            * transpose one cross-type time series data by TIMEID;
17586 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
17587 +                by _TSID_ &crossIDVar;
17588 +                var &&&TSVar&i;
17589 +            run;
17590 +        %end;
17592 +        * stack all horizontal time series;
17593 +        data &outDS;
17594 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
17595 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
17596 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
17597 +            %do i=1 %to &num_TSVar;
17598 +                if in&i then do;
17599 +                    _NAMEID_ ="&&&TSVar&i";
17600 +                    _ROLE_   ="&&&TSRole&i";
17601 +                end;
17602 +            %end;
17603 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
17604 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
17605 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
17606 +        run;
17607 +    %end;
17608 +%end;
17609 +%else %do;
17611 +    proc sql noprint;
17612 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
17613 +            order by _NAMEID_
17614 +        ;
17615 +    quit;
17617 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
17618 +        * transpose the panel-type time series data by TSID;
17619 +        proc sort data=&inDS out=_emtstp_tmpDat;
17620 +            by &timeIDvar;
17621 +        proc transpose data=_emtstp_tmpDat
17622 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
17623 +            by &timeIDVar;
17624 +            var &panelTSVar;
17625 +        run;
17626 +        proc datasets lib=work nolist;
17627 +            modify _emtstp_tmpDat2;
17628 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
17629 +            run; quit;
17630 +    %end;
17631 +    %else %do;
17632 +        * transpose the panel-type time series data by TIMEID;
17633 +        proc sort data=&inDS out=_emtstp_tmpDat;
17634 +            by &timeIDvar;
17635 +        data _emtstp_tmpDat;
17636 +            set _emtstp_tmpDat;
17637 +            _tmp_ind=_n_;
17638 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
17639 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
17640 +            ID _tmp_ind;
17641 +            var &panelTSVar;
17642 +        run;
17643 +    %end;
17645 +      * merge ID maps to the transpose data set;
17646 +      proc sql noprint;
17647 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
17648 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
17649 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
17650 +          ;
17651 +      quit;
17653 +      * update the TS ID map;
17654 +      data &outIDMap;
17655 +          set &inIDMap;
17656 +      run;
17657 +%end;
17659 +proc datasets lib=work nolist;
17660 +    delete _emtstp:;
17661 +run; quit;
17663 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_TRAIN.SOURCE.
17665 +/*----------------------------------------------------------------------------------+
17666 + |
17667 + |   Title :  TS ESM Forecasting Node
17668 + |
17669 + |
17670 + |   SUPPORT: Taiyeong Lee (taiyeong.lee@sas.com)
17671 + |
17672 + +-----------------------------------------------------------------------------------*/
17674 +%macro EM_TSESM_TRAIN;
17676 +   /*---------- Check and assign the input data set --------------------------*/
17678 +    %let _IMPORT_DATA  = ;
17679 +    %let _IMPORT_CMETA = ;
17680 +    %let _DATA_EMINFO  = ;
17681 +    %let _EXPORT_DATA  = ;
17682 +    %let _FILE_CDELTA  = ;
17684 +    %if &EM_IMPORT_DATA ne  %then %do;
17685 +           %let _IMPORT_DATA   = &EM_IMPORT_DATA;
17686 +           %let _IMPORT_CMETA  = &EM_IMPORT_DATA_CMETA;
17687 +           %let _DATA_EMINFO   = &EM_IMPORT_DATA_EMINFO;
17688 +           %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
17689 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
17691 +    %end;
17692 +    %else %if &EM_IMPORT_TRANSACTION ne  %then %do;
17693 +           %let _IMPORT_DATA   = &EM_IMPORT_TRANSACTION;
17694 +           %let _IMPORT_CMETA  = &EM_IMPORT_TRANSACTION_CMETA;
17695 +           %let _DATA_EMINFO   = &EM_IMPORT_TRANSACTION_EMINFO;
17696 +           %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
17697 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRANSACTION;
17698 +    %end;
17699 +    %else %do;
17700 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
17701 +           %goto ENDLINE;
17702 +    %end;
17703 +/*-------------  check time id variable -----------------------------*/
17704 +%local _numTimeIDs;
17705 +%let _numTimeIDs=0;
17707 +proc sql noprint;
17708 +    select count(*) into :_numTimeIDs
17709 +    from &EM_DATA_VARIABLESET
17710 +    where upcase(role) eq 'TIMEID' and upcase(strip(level)) eq 'INTERVAL' and upcase(strip(use)) in ('Y' 'D');
17711 +quit;
17713 +%if &_numTimeIDs eq 0 %then %do;
17715 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
17716 +    %put &em_codebar;
17717 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
17718 +    %put &errormsg;
17719 +    %put &em_codebar;
17720 +    %goto ENDLINE;
17722 +%end;
17723 +%else %if &_numTimeIDs gt 1 %then %do;
17725 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
17726 +    %put &em_codebar;
17727 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
17728 +    %put &errormsg;
17729 +    %put &em_codebar;
17730 +    %goto ENDLINE;
17732 +%end;
17734 +   %let _nivars = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
17735 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17736 +        %if &_nivars < 1 %then %do;
17737 +              %put &em_codebar;
17738 +              %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.need1intervalrejectinput_ERR , NOQUOTE));
17739 +              %put &errormsg;
17740 +              %put &em_codebar;
17741 +              %let  EMEXCEPTIONSTRING = exception.server.tsdm.need1intervalrejectinput;
17742 +              %goto ENDLINE;
17743 +         %end;
17745 +   %end;
17746 +   %else %do;
17748 +        /* will forecast a target variable (with crossids) or variables (panel) */
17750 +        %if &EM_NUM_INTERVAL_TARGET < 1 %then %do;
17751 +             %put &em_codebar;
17752 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.USE1INTERVALTARGET_ERR , NOQUOTE));
17753 +             %put &errormsg;
17754 +             %put &em_codebar;
17755 +             %let EMEXCEPTIONSTRING = exception.server.tsdm.USE1INTERVALTARGET;
17756 +             %goto ENDLINE;
17757 +        %end;
17759 +        %if (&EM_NUM_CROSSID > 0) and (&EM_NUM_INTERVAL_TARGET > 1) %then %do;
17761 +             %put &em_codebar;
17762 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.csidonly1inttarget_err , NOQUOTE));
17763 +             %put &errormsg;
17764 +             %put &em_codebar;
17765 +             %let EMEXCEPTIONSTRING = exception.server.tsdm.csidonly1inttarget;
17766 +             %goto ENDLINE;
17767 +        %end;
17769 +    %end;
17771 +    %if  &EM_PROPERTY_STARTSUM > &EM_PROPERTY_FCLEAD %then %do;
17773 +             %put &em_codebar;
17774 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.startsumlessflead_err , NOQUOTE));
17775 +             %put &errormsg;
17776 +             %put &em_codebar;
17777 +             %let  EMEXCEPTIONSTRING =exception.server.tsdm.startsumlessflead;
17778 +             %goto ENDLINE;
17779 +    %end;
17781 +   /* Check strictly positive seq for &EM_PROPERTY_FCMETHOD eq WINTERS or MULTSEASONAL */
17783 +%macro TSESM_input_varlist(varlist);
17784 +   %local outlist i;
17785 +   %let i = 2;
17786 +   %let outlist = %scan(&varlist, 1, ' ' );
17788 +   %do %while (%scan(&varlist, &i, ' ' ) ne );
17790 +      %let outlist = &outlist  %str(,) %scan(&varlist, &i, ' ' );
17791 +      %let i  = %eval(&i+1);
17792 +   %end;
17794 +   &outlist
17795 +%mend TSESM_input_varlist;
17797 +    %if  &EM_PROPERTY_FCMETHOD eq WINTERS or &EM_PROPERTY_FCMETHOD eq MULTSEASONAL %then %do;
17798 +       %let _tsseq_flag = 0;
17800 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17801 +          proc sql noprint;
17802 +             select min(min( %TSESM_input_varlist(%EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)),100 )  into :_tsseq_min from &_IMPORT_DATA;
17803 +          quit;
17804 +          %if %sysfunc(floor(&_tsseq_min))  < 0 %then  %let  _tsseq_flag = 1;
17805 +       %end;
17806 +       %else %do;
17807 +         proc sql noprint;
17808 +            select min(min( %TSESM_input_varlist(%EM_TARGET)),100 ) into :_tsseq_min from &_IMPORT_DATA;
17809 +         quit;
17810 +         %if %sysfunc(floor(&_tsseq_min))  < 0 %then  %let  _tsseq_flag = 1;
17811 +       %end;
17812 +       %if &_tsseq_flag = 1 %then %do;
17813 +             %put &em_codebar;
17814 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.strictpositive_err , NOQUOTE));
17815 +             %put &errormsg;
17816 +             %put &em_codebar;
17817 +             %let  EMEXCEPTIONSTRING =exception.server.tsdm.strictpositive;
17818 +             %goto ENDLINE;
17819 +       %end;
17820 +    %end;
17824 +   /* When Forecast Input Time Series is Yes, Output Data Type is always Default */
17825 +   %let _EXPORTDATA = &EM_PROPERTY_EXPORTDATA;
17826 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17827 +      %let _EXPORTDATA = DEFAULT   ;
17828 +      %let EM_PROPERTY_EXPORTDATA  = DEFAULT   ;
17830 +   %end;
17832 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
17833 +    %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
17835 +    /*---- EM_TS_CreateMetadata do validation of Time ID and return EM_TS_ERR   ----------------------------*/
17837 +    %EM_TS_CreateMetadata(inDS=&_IMPORT_DATA, outDS =&EM_USER_TSMETA, variableSet =&EM_DATA_VARIABLESET, timeInterval=&EM_PROPERTY_TIMEINTERVAL, rc=);
17839 +    %if &EM_TS_ERR > 0 %then  %do;
17841 +       %let EM_TS_ERR = 0;
17842 +       %goto ENDLINE;
17843 +    %end;
17845 +    /*----- Get time interval ---------------------------*/
17847 +    %EM_TS_GETTSMETAVARS(TimeInterval=_timeinterval);
17849 +    /*--- _EXPORT_DATA will be used as an input data becuase  _TSID_  is needed to run TS ESM Node */
17851 +    %EM_TS_CreateIDMap(inDS=&_IMPORT_DATA, outIDMap =&EM_USER_TSIDMAP, outDS =&_EXPORT_DATA, variableSet =&EM_DATA_VARIABLESET, TSIDbyCrossID =Y);
17853 +    /*----------- Modify TSID MAP --------------------------------*/
17855 +    %if (&EM_NUM_CROSSID > 0) %then %do;
17856 +         %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17857 +             data &EM_USER_TSIDMAP;
17858 +                  set &EM_USER_TSIDMAP;
17859 +                  if upcase(strip(_ROLE_)) ="INPUT" then output;
17860 +             run;
17861 +         %end;
17862 +         %else %do;
17863 +             data &EM_USER_TSIDMAP;
17864 +                  set &EM_USER_TSIDMAP;
17865 +                  if upcase(strip(_ROLE_)) ="TARGET" then output;
17866 +             run;
17867 +         %end;
17868 +    %end;
17869 +    %else %do;
17870 +         %if &_EXPORTDATA ne DEFAULT  %then %do;
17872 +             %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17873 +                 data &EM_USER_TSIDMAP;
17874 +                      set &EM_USER_TSIDMAP; retain _tmptsid 0;
17875 +                      if upcase(strip(_ROLE_)) ="INPUT" then do; _tmptsid=_tmptsid+1; _TSID_=_tmptsid;output;end;
17876 +                      drop _tmptsid;
17877 +                 run;
17878 +             %end;
17879 +             %else %do;
17880 +                 data &EM_USER_TSIDMAP;
17881 +                      set &EM_USER_TSIDMAP; retain _tmptsid 0;
17882 +                      if upcase(strip(_ROLE_)) ="TARGET" then do; _tmptsid=_tmptsid+1; _TSID_=_tmptsid;output;end;
17883 +                      drop _tmptsid;
17884 +                 run;
17886 +             %end;
17887 +         %end;
17888 +    %end;
17893 +    %let _tsidVar = ;
17894 +    %let _existsgmtvar = N;
17896 +    %if %EM_CROSSID ne %then %do;
17897 +        %let _tsidVar =_TSID_ ;
17898 +        /*---------  check Segmentvar : may not need implement, will decided at the next version -----------
17899 +                     So the _segment_ related codes have not been removed in other source codes
17900 +         ---------------------------------------------------------------------------------------------------
17901 +        %let j=1;
17902 +        %do %while(%scan(%EM_CROSSID, &j) ne );
17903 +            %let _csvar=%scan(%EM_CROSSID, &j);
17904 +            %if &_csvar = _SEGMENT_ %then %let _existsgmtvar =Y;
17905 +            %let j=%eval(&j+1);
17906 +        %end;
17907 +        %if &_existsgmtvar = Y %then %let _tsidVar = _SEGMENT_;
17908 +        +-------------------------------------------*/
17909 +    %end;
17911 +    /*----------- Forecasting ----------------------------------*/
17913 +    %EM_GETNAME(KEY=OUTEST, TYPE=DATA);
17914 +    %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
17915 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
17916 +    %EM_GETNAME(KEY=OUTSTAT, TYPE=DATA);
17917 +    %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
17918 +    %EM_GETNAME(KEY=OUTCLUS, TYPE=DATA);
17919 +    %EM_GETNAME(KEY=OUTLIER, TYPE=DATA);
17920 +    %EM_GETNAME(KEY=OUTPRED, TYPE=DATA);
17921 +    %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
17922 +    %EM_GETNAME(KEY=OUTLIERDS, TYPE=DATA);
17925 +    %if &EM_PROPERTY_FCMETHOD ne BEST %then %do;
17927 +       %if &EM_PROPERTY_SEASONALITY eq DEFAULT %then %do;
17928 +           %if ( &_timeinterval eq YEAR ) or ( &_timeinterval eq DTYEAR ) %then %do;
17929 +               %if (&EM_PROPERTY_FCMETHOD eq ADDSEASONAL ) or (&EM_PROPERTY_FCMETHOD eq MULTSEASONAL)
17930 +                   or (&EM_PROPERTY_FCMETHOD eq ADDWINTERS) or (&EM_PROPERTY_FCMETHOD eq WINTERS) %then %do;
17931 +                   %let  EMEXCEPTIONSTRING =exception.server.tsdm.requirenonseasonalmodel;
17932 +                   %goto ENDLINE;
17933 +               %end;
17934 +           %end;
17935 +       %end;
17937 +       %EM_TSESM_Forecast(indata=&_EXPORT_DATA,
17938 +                          method=&EM_PROPERTY_FCMETHOD,
17939 +                          timeinterval=&_timeinterval,
17940 +                          timeid=%EM_TIMEID ,
17941 +                          target=%EM_TARGET ,
17942 +                          tsidvar = &_tsidVar,
17943 +                          lead=&EM_PROPERTY_FCLEAD,
17944 +                          back=&EM_PROPERTY_FCBACK,
17945 +                          startsum=&EM_PROPERTY_STARTSUM,
17946 +                          seasonality=&EM_PROPERTY_SEASONALITY,
17947 +                          alpha=&EM_PROPERTY_ALPHA,
17948 +                          accumulate=&EM_PROPERTY_ACCUMULATE,
17949 +                          extendedvalue = &EM_PROPERTY_EXTENDEDVALUE,
17950 +                          outest=&EM_USER_OUTEST,
17951 +                          outdata=&EM_USER_OUTDATA,
17952 +                          outfor =&EM_USER_OUTFORCST ,
17953 +                          outstat = &EM_USER_OUTSTAT ,
17954 +                          outsum=&EM_USER_OUTSUM
17955 +                          );
17956 +    %end;
17957 +    %else %do;
17958 +           %let n_model = 0;
17959 +           %if &EM_PROPERTY_SIMPLE eq Y %then %let n_model = %eval(&n_model+1);
17960 +           %if &EM_PROPERTY_DOUBLE eq Y %then %let n_model = %eval(&n_model+1);
17961 +           %if &EM_PROPERTY_LINEAR eq Y %then %let n_model = %eval(&n_model+1);
17962 +           %if &EM_PROPERTY_DAMPTREND eq Y %then %let n_model = %eval(&n_model+1);
17963 +           %if (&_timeinterval ne YEAR ) and ( &_timeinterval ne DTYEAR ) %then %do;
17964 +               %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then  %let n_model = %eval(&n_model+1);
17965 +               %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %let n_model = %eval(&n_model+1);
17966 +               %if (&EM_PROPERTY_ADDWINTERS eq Y) %then   %let n_model = %eval(&n_model+1);
17967 +               %if (&EM_PROPERTY_WINTERS eq Y) %then      %let n_model = %eval(&n_model+1);
17968 +           %end;
17969 +           %if &n_model eq 0 %then %do;
17970 +                %let  EMEXCEPTIONSTRING =exception.server.tsdm.zerocandidatemodel;
17971 +                %GOTO ENDLINE;
17972 +           %end;
17974 +       %EM_TSESM_Best_Forecast(indata=&_EXPORT_DATA,
17975 +                          method=&EM_PROPERTY_FCMETHOD,
17976 +                          criterion=&EM_PROPERTY_BESTCRIT,
17977 +                          timeinterval=&_timeinterval,
17978 +                          timeid=%EM_TIMEID ,
17979 +                          target=%EM_TARGET ,
17980 +                          tsidvar = &_tsidVar,
17981 +                          lead=&EM_PROPERTY_FCLEAD,
17982 +                          back=&EM_PROPERTY_FCBACK,
17983 +                          startsum=&EM_PROPERTY_STARTSUM,
17984 +                          seasonality=&EM_PROPERTY_SEASONALITY,
17985 +                          alpha=&EM_PROPERTY_ALPHA,
17986 +                          accumulate=&EM_PROPERTY_ACCUMULATE,
17987 +                          extendedvalue = &EM_PROPERTY_EXTENDEDVALUE,
17988 +                          outest=&EM_USER_OUTEST,
17989 +                          outdata=&EM_USER_OUTDATA,
17990 +                          outfor =&EM_USER_OUTFORCST ,
17991 +                          outstat = &EM_USER_OUTSTAT ,
17992 +                          outsum=&EM_USER_OUTSUM
17993 +                         );
17994 +    %end;
17996 +    %EM_TS_Time2Seq(inDS=&EM_USER_OUTFORCST,tsmeta=&EM_USER_TSMETA);
17997 +    %EM_TS_Time2Seq(inDS=&EM_USER_OUTDATA,tsmeta=&EM_USER_TSMETA);
17998 +    %EM_TS_Time2Seq(inDS=&_EXPORT_DATA,tsmeta=&EM_USER_TSMETA);
18001 +    %EM_TSESM_MakeOutlierIndex(indata=&EM_USER_OUTFORCST,
18002 +                               timeid=%EM_TIMEID,
18003 +                               outoutlier=&EM_USER_OUTLIER,
18004 +                               outlierds=&EM_USER_OUTLIERDS,
18005 +                               outdata=&EM_USER_OUTFORCST
18006 +                               );
18008 +    %EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
18009 +                          target=%EM_TARGET,
18010 +                          timeid=%EM_TIMEID,
18011 +                          outdata=&EM_USER_OUTPRED
18012 +                         );
18015 +    %ENDLINE:
18016 +%mend EM_TSESM_TRAIN;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS1.TSESM_VARIABLESET.
      WHERE UPCASE(role)='TIMEID';
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
NOTE: View EMWS1.FIMPORT4_TRAIN.VIEW used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
 
NOTE: There were 1823 observations read from the data set EMWS1.FIMPORT4_DATA.
NOTE: Table WORK._EMTSCM_INDS created, with 1823 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.13 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: Number of time vectors processed: 1
NOTE: There were 1823 observations read from the data set WORK._EMTSCM_INDS.
NOTE: The data set WORK._EMTSCM_META has 1 observations and 24 variables.
NOTE: PROCEDURE TIMEID used (Total process time):
      real time           0.07 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_LABEL created, with 1 rows and 2 columns.
 
NOTE: Table WORK._EMTSCM_META2 created, with 1 rows and 25 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.07 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      379:48    399:62    415:122   425:137   435:136   445:152
NOTE: There were 1 observations read from the data set WORK._EMTSCM_META2.
NOTE: The data set EMWS1.TSESM_TSMETA has 1 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.21 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: The file WORK._EM_TSCM: (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS1.TSESM_TSMETA.
NOTE: The PROCEDURE PRINT printed page 2.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTSCM_CONTENTS has 14 observations and 1 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.10 seconds
      cpu time            0.09 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 4 observations read from the data set EMWS1.TSESM_VARIABLESET.
      WHERE (UPCASE(STRIP(level))='INTERVAL') and (((UPCASE(STRIP(role))='INPUT') and UPCASE(STRIP(use)) in ('D', 'Y')) or ((UPCASE(STRIP(role))='REJECTED') and (UPCASE(STRIP(use))='Y')) or ((UPCASE(STRIP(role))='TARGET') and UPCASE(STRIP(use)) in ('D',
      'Y')));
NOTE: The data set EMWS1.TSESM_TSIDMAP has 4 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: View EMWS1.FIMPORT4_TRAIN.VIEW used (Total process time):
      real time           0.05 seconds
      cpu time            0.03 seconds
 
NOTE: There were 1823 observations read from the data set EMWS1.FIMPORT4_DATA.
NOTE: There were 1823 observations read from the data set EMWS1.FIMPORT4_TRAIN.
NOTE: The data set EMWS1.TSESM_TRAIN has 1823 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.06 seconds
 
 
 
NOTE: Variable _varname_ is uninitialized.
NOTE: There were 4 observations read from the data set EMWS1.TSESM_TSIDMAP.
NOTE: The data set EMWS1.TSESM_TSIDMAP has 4 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.06 seconds
 
 
 
NOTE: Deleting WORK._EMTSCM_CONTENTS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_INDS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_LABEL (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META2 (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.08 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.07 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT1 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST1 has 4 observations and 8 variables.
NOTE: The data set WORK._OUTFOR1 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT1 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM1 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.19 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT2 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST2 has 4 observations and 8 variables.
NOTE: The data set WORK._OUTFOR2 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT2 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM2 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.16 seconds
      cpu time            0.06 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT3 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST3 has 8 observations and 8 variables.
NOTE: The data set WORK._OUTFOR3 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT3 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM3 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.16 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT4 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST4 has 12 observations and 8 variables.
NOTE: The data set WORK._OUTFOR4 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT4 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM4 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.23 seconds
      cpu time            0.07 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT5 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST5 has 12 observations and 8 variables.
NOTE: The data set WORK._OUTFOR5 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT5 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM5 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.20 seconds
      cpu time            0.07 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT6 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST6 has 8 observations and 8 variables.
NOTE: The data set WORK._OUTFOR6 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT6 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM6 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.17 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.06 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT7 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST7 has 8 observations and 8 variables.
NOTE: The data set WORK._OUTFOR7 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT7 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM7 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.17 seconds
      cpu time            0.07 seconds
 
 
 
NOTE: There were 1823 observations read from the data set EMWS1.TSESM_TRAIN.
NOTE: The data set WORK._TMPDATA has 1823 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 4
NOTE: Number of forecasts requested: 4
NOTE: Number of forecasts failed: 0
NOTE: There were 1823 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT8 has 1825 observations and 5 variables.
NOTE: The data set WORK._OUTEST8 has 12 observations and 8 variables.
NOTE: The data set WORK._OUTFOR8 has 7300 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT8 has 4 observations and 57 variables.
NOTE: The data set WORK._OUTSUM8 has 4 observations and 15 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.19 seconds
      cpu time            0.07 seconds
 
 
NOTE: Table WORK.TSSTAT created, with 32 rows and 58 columns.
 
NOTE: Table WORK.TSEST created, with 68 rows and 9 columns.
 
NOTE: Table WORK.TSFOR created, with 58400 rows and 9 columns.
 
NOTE: Table WORK.TSOUT created, with 14600 rows and 6 columns.
 
NOTE: Table WORK.TSSUM created, with 32 rows and 16 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.40 seconds
      cpu time            0.06 seconds
 
 
 
NOTE: There were 32 observations read from the data set WORK.TSSTAT.
NOTE: The data set WORK.BESTMDL has 32 observations and 58 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 32 observations read from the data set WORK.BESTMDL.
NOTE: The data set WORK.BESTMDL has 4 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK.BESTID created, with 4 rows and 4 columns.
 
NOTE: Table EMWS1.TSESM_OUTFORCST created, with 7300 rows and 11 columns.
 
NOTE: Table EMWS1.TSESM_OUTSTAT created, with 4 rows and 59 columns.
 
NOTE: Table EMWS1.TSESM_OUTEST created, with 8 rows and 10 columns.
 
NOTE: Table EMWS1.TSESM_OUTSUM created, with 4 rows and 18 columns.
 
NOTE: PROC SQL statements are executed immediately; The RUN statement has no effect.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.53 seconds
      cpu time            0.14 seconds
 
 
 
NOTE: There were 4 observations read from the data set WORK.BESTMDL.
NOTE: The data set WORK._TMPDS1 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS2 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS3 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS4 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS5 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS6 has 4 observations and 58 variables.
NOTE: The data set WORK._TMPDS7 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS8 has 0 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.18 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1825 observations read from the data set WORK._OUT1.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT1.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT2.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT3.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT4.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT5.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT6.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT7.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: There were 1825 observations read from the data set WORK._OUT8.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
 
 
 
WARNING: The variable mdlID in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _MODEL_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable MSE in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: The data set EMWS1.TSESM_OUTDATA has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 8 observations read from the data set EMWS1.TSESM_OUTEST.
NOTE: The data set EMWS1.TSESM_OUTEST has 8 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 7300 observations read from the data set EMWS1.TSESM_OUTFORCST.
NOTE: The data set EMWS1.TSESM_OUTFORCST has 7300 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 4 observations read from the data set EMWS1.TSESM_OUTSTAT.
NOTE: The data set EMWS1.TSESM_OUTSTAT has 4 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 4 observations read from the data set EMWS1.TSESM_OUTSUM.
NOTE: The data set EMWS1.TSESM_OUTSUM has 4 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS1.TSESM_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS1.TSESM_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.05 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS1.TSESM_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.06 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 7300 observations read from the data set EMWS1.TSESM_OUTFORCST.
NOTE: The data set EMWS1.TSESM_OUTFORCST has 7300 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
 
 
 
WARNING: The variable _TSID_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _SEGMENT_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _NAMEID_ in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 7300 observations read from the data set EMWS1.TSESM_OUTFORCST.
NOTE: The data set EMWS1.TSESM_OUTLIER has 7292 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 7292 observations read from the data set EMWS1.TSESM_OUTLIER.
NOTE: The data set EMWS1.TSESM_OUTLIERDS has 385 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
WARNING: The variable _TSID_ in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 7300 observations read from the data set EMWS1.TSESM_OUTFORCST.
NOTE: The data set EMWS1.TSESM_OUTPRED has 8 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
18020
18021
18022  *------------------------------------------------------------*;
18023  * End TRAIN: TSESM;
18024  *------------------------------------------------------------*;
 
18025  *------------------------------------------------------------*;
18026  * Close any missing semi colons;
18027  *------------------------------------------------------------*;
18028  ;
18029  ;
18030  ;
18031  ;
18032  quit;
18033  *------------------------------------------------------------*;
18034  * Close any unbalanced quotes;
18035  *------------------------------------------------------------*;
18036  /*; *"; *'; */
18037  ;
18038  run;
18039  quit;
18040  /* Reset EM Options */
18041  options formchar="|----|+|---+=|-/\<>*";
18042  options nocenter ls=256 ps=10000;
18043  goptions reset=all device=GIF NODISPLAY;
 
*------------------------------------------------------------*
* Score Log
Date:                22 December 2019
Time:                20:01:51 o'clock
*------------------------------------------------------------*
18145  %let EMEXCEPTIONSTRING=;
18146  *------------------------------------------------------------*;
18147  * SCORE: TSESM;
18148  *------------------------------------------------------------*;
18149  %let EM_ACTION = SCORE;
18150  %let syscc = 0;
18151
18152  %macro EM_TSESM_MAIN;
18153
18154     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
18155     %include temp;
18156     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
18157     %include temp;
18158     filename temp;
18159
18160     %if %upcase(&EM_ACTION) = CREATE %then %do;
18161         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
18162         %include temp;
18163         filename temp;
18164         %EM_TSESM_CREATE;
18165     %end;
18166     %else
18167     %if %upcase(&EM_ACTION) = TRAIN %then %do;
18168          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
18169             %include temp;
18170             filename temp;
18171          %EM_TSESM_TRAIN;
18172     %end;
18173     %else
18174     %if %upcase(&EM_ACTION) = SCORE %then %do;
18175             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
18176             %include temp;
18177             filename temp;
18178           %EM_TSESM_SCORE;
18179     %end;
18180     %else
18181     %if %upcase(&EM_ACTION) = REPORT %then %do;
18182             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
18183             %include temp;
18184             filename temp;
18185            %EM_TSESM_REPORT;
18186     %end;
18187  %mend EM_TSESM_MAIN;
18188  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
18189 +/*----------------------------------------------------------------------------------+
18190 + |
18191 + |   Title :  Time Series data Mining Forcating Macros
18192 + |
18193 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
18194 + |
18195 + |
18196 + +-----------------------------------------------------------------------------------*/
18199 +%macro EM_TSESM_Forecast(indata=,
18200 +                method=,
18201 +                timeinterval=,
18202 +                timeid= ,
18203 +                target= ,
18204 +                tsidvar=,
18205 +                lead=,
18206 +                back=,
18207 +                startsum=,
18208 +                accumulate=,
18209 +                seasonality=,
18210 +                alpha=,
18211 +                extendedvalue=,
18212 +                outest = ,
18213 +                outdata = ,
18214 +                outfor = ,
18215 +                outstat = ,
18216 +                outsum=
18217 +   );
18220 +   %if &tsidvar eq _SEGMENT_ %then %do;
18221 +       proc sort data=&indata out=_tmpdata;
18222 +            by  &tsidvar %EM_CROSSID &timeid ;
18223 +       run;
18224 +       proc timeseries  data =_tmpdata out=_tmpdata;
18225 +            by  &tsidvar %EM_CROSSID;
18226 +            id &timeid interval=&timeinterval accumulate=&accumulate;
18227 +            var &target / ;
18228 +       run;
18229 +       proc esm data =_tmpdata
18230 +   %end;
18231 +   %else %do;
18232 +       proc sort data= &indata out=_tmpdata;
18233 +            by  &tsidvar %EM_CROSSID &timeid ;
18234 +       run;
18235 +       proc esm data = _tmpdata
18236 +   %end;
18237 +            lead=&lead  back=&back startsum=&startsum
18239 +   %if &seasonality ne DEFAULT %then %do;
18240 +            seasonality = &seasonality
18241 +   %end;
18244 +            out=&outdata
18245 +            outest=&outest
18246 +            outfor =&outfor
18247 +            outstat=&outstat
18248 +            outsum= &outsum
18249 +       ;
18250 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
18252 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18253 +            %if &target ne %then %do;
18254 +            forecast &target   /  model = none alpha=&alpha;
18255 +            %end;
18256 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18257 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
18258 +            %end;
18259 +        %end;
18260 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
18261 +            %if &target ne %then %do;
18262 +            forecast &target /  model =&method alpha=&alpha;
18263 +            %end;
18264 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18265 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
18266 +            %end;
18267 +        %end;
18268 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
18269 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
18270 +        %end;
18272 +   %if &tsidvar ne %then %do;
18273 +        by &tsidvar %EM_CROSSID ;
18274 +   %end;
18275 +   run;
18276 +%mend EM_TSESM_Forecast;
18279 +%macro EM_TSESM_CreateOutFor(indata=,
18280 +                            target=,
18281 +                            timeid=,
18282 +                            tsidVar=,
18283 +                            percent=,
18284 +                            outdata=);
18286 +  %let lowerBound = L&percent;
18287 +  %let upperBound = U&percent;
18289 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
18290 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
18291 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
18292 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
18293 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
18294 +       ds_std(rename=(&target=STD) drop=_TYPE_);
18295 +     set &indata;
18296 +       if _TYPE_="FORECAST" then output ds_fore;
18297 +       if _TYPE_="RESIDUAL" then output ds_resid;
18298 +       if _TYPE_="ACTUAL" then output ds_act;
18299 +       if _TYPE_="&lowerBound" then output ds_lower;
18300 +       if _TYPE_="&upperBound" then output ds_upper;
18301 +       if _TYPE_="STD" then output ds_std;
18302 +  run;
18304 +  data &outdata;
18305 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
18306 +       by &tsidVar &timeid;
18307 +       label  FORECAST = "Forecast";
18308 +       label  ACTUAL = "Actual";
18309 +       label  RESIDUAL = "Residual";
18310 +       label  LBOUND = "Lower Bound";
18311 +       label  UBOUND = "Upper Bound";
18312 +       label   STD = "Standard Deviation";
18313 +  run;
18314 +%mend EM_TSESM_CreateOutFor;
18317 +%macro EM_TSESM_CreateOutExpand(indata=,
18318 +                       target=,
18319 +                       timeid=,
18320 +                       tsidVar=,
18321 +                       percent=,
18322 +                       outlower=,
18323 +                       outupper=,
18324 +                       outdata=);
18326 +  %let lowerBound = L&percent;
18327 +  %let upperBound = U&percent;
18329 +  /*proc print data=&indata(obs=200);
18330 +  run;
18331 +  */
18333 +  data ds_fore(drop=&target)
18334 +       ds_lower(drop=&target)
18335 +       ds_upper(drop=&target)
18336 +       ds_act;
18337 +     set &indata;
18338 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
18339 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
18340 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
18341 +       if _TYPE_="ACTUAL" then output ds_act;
18342 +  run;
18344 +  /*
18345 +  proc print data = ds_fore;
18346 +  proc print data=ds_act;
18347 +  run;
18348 +  */
18349 +  data &outdata;
18350 +       merge ds_act ds_fore;
18351 +       by &tsidVar &timeid;
18352 +  run;
18354 +  data &outlower;
18355 +       merge ds_act ds_lower;
18356 +       by &tsidVar &timeid;
18357 +  run;
18359 +  data &outupper;
18360 +       merge ds_act ds_upper;
18361 +       by &tsidVar &timeid;
18362 +  run;
18363 +  /*
18364 +  proc print data=&outdata(obs=300);
18365 +  proc print data=&outlower(obs=300);
18366 +  proc print data=&outupper(obs=300);
18367 +  run;
18368 +  */
18369 +%mend EM_TSESM_CreateOutExpand;
18373 +%macro EM_TSESM_MakeOutClus(indata=,
18374 +                   target=,
18375 +                   timeid=,
18376 +                   tsidVar=,
18377 +                   percent=,
18378 +                   outlower=,
18379 +                   outupper=,
18380 +                   outdata=);
18383 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
18385 +  data &outdata(rename=(_NAME_ =_NAMEID_));
18386 +       set &indata;
18387 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
18388 +  run;
18390 +  %let dsid=%sysfunc(open(&outdata));
18391 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
18392 +  %let dsid=%sysfunc(close(&dsid));
18394 +  %if &vn_name > 0 %then %do;
18395 +      data &outdata(drop=_NAMEID_);
18396 +           merge &EM_USER_TSIDMAP &outdata;
18397 +           by _TSID_;
18398 +      run;
18399 +  %end;
18400 +  %else %do;
18401 +      proc sort data= &outdata; by _NAMEID_;
18402 +      run;
18403 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
18404 +      run;
18405 +      data &outdata(drop=_NAMEID_);
18406 +           merge &EM_USER_TSIDMAP &outdata;
18407 +           by _NAMEID_;
18408 +      run;
18409 +  %end;
18411 +%mend EM_TSESM_MakeOutClus;
18414 +%macro EM_TSESM_CreateOutEst(indata=,
18415 +                    target=,
18416 +                    timeid=,
18417 +                    outdata=);
18419 +%mend EM_TSESM_CreateOutEst;
18422 +%macro EM_TSESM_Best_Forecast(indata=,
18423 +                method=,
18424 +                timeinterval=,
18425 +                timeid= ,
18426 +                target= ,
18427 +                tsidvar=,
18428 +                lead=,
18429 +                back=,
18430 +                startsum=,
18431 +                accumulate=,
18432 +                seasonality=,
18433 +                alpha=,
18434 +                criterion=,
18435 +                extendedvalue=,
18436 +                outest = ,
18437 +                outdata = ,
18438 +                outfor = ,
18439 +                outstat = ,
18440 +                outsum=
18441 +   );
18443 +   %let _indata = &indata;
18445 +   %if &tsidvar eq _SEGMENT_ %then %do;
18446 +       proc sort data=&indata out=_tmpdata;
18447 +            by  &tsidvar %EM_CROSSID &timeid ;
18448 +       run;
18449 +       proc timeseries  data =_tmpdata out=_tmpdata;
18450 +            by  &tsidvar %EM_CROSSID ;
18451 +            id &timeid interval=&timeinterval accumulate=&accumulate;
18452 +            var &target / ;
18453 +       run;
18454 +       %let _indata = _tmpdata;
18455 +   %end;
18457 +   %let n_model = 0;
18459 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
18461 +       %let n_model = %eval(&n_model+1);
18463 +       %let _ds_out =_out&n_model;
18464 +       %let _ds_outest =_outest&n_model;
18465 +       %let _ds_outfor =_outfor&n_model;
18466 +       %let _ds_outstat =_outstat&n_model;
18467 +       %let _ds_outsum=_outsum&n_model;
18469 +       %EM_TSESM_ESM(method=SIMPLE,
18470 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18471 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18472 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18473 +        );
18475 +   %end;
18476 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
18478 +       %let n_model = %eval(&n_model+1);
18480 +       %let _ds_out =_out&n_model;
18481 +       %let _ds_outest =_outest&n_model;
18482 +       %let _ds_outfor =_outfor&n_model;
18483 +       %let _ds_outstat =_outstat&n_model;
18484 +       %let _ds_outsum=_outsum&n_model;
18486 +       %EM_TSESM_ESM(method=DOUBLE,
18487 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18488 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18489 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18490 +       );
18491 +   %end;
18493 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
18495 +       %let n_model = %eval(&n_model+1);
18496 +       %let _ds_out =_out&n_model;
18497 +       %let _ds_outest =_outest&n_model;
18498 +       %let _ds_outfor =_outfor&n_model;
18499 +       %let _ds_outstat =_outstat&n_model;
18500 +       %let _ds_outsum=_outsum&n_model;
18502 +       %EM_TSESM_ESM(method=LINEAR,
18503 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18504 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18505 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18506 +        );
18507 +   %end;
18509 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
18511 +       %let n_model = %eval(&n_model+1);
18513 +       %let _ds_out =_out&n_model;
18514 +       %let _ds_outest =_outest&n_model;
18515 +       %let _ds_outfor =_outfor&n_model;
18516 +       %let _ds_outstat =_outstat&n_model;
18517 +       %let _ds_outsum=_outsum&n_model;
18519 +       %EM_TSESM_ESM(method=DAMPTREND,
18520 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18521 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18522 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18523 +            );
18524 +   %end;
18525 +   /*------- Seasonal model ------*/
18527 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
18529 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
18531 +       %let n_model = %eval(&n_model+1);
18533 +       %let _ds_out =_out&n_model;
18534 +       %let _ds_outest =_outest&n_model;
18535 +       %let _ds_outfor =_outfor&n_model;
18536 +       %let _ds_outstat =_outstat&n_model;
18537 +       %let _ds_outsum=_outsum&n_model;
18539 +       %EM_TSESM_ESM(method=WINTERS,
18540 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18541 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18542 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18543 +        );
18544 +   %end;
18546 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
18548 +       %let n_model = %eval(&n_model+1);
18550 +       %let _ds_out =_out&n_model;
18551 +       %let _ds_outest =_outest&n_model;
18552 +       %let _ds_outfor =_outfor&n_model;
18553 +       %let _ds_outstat =_outstat&n_model;
18554 +       %let _ds_outsum=_outsum&n_model;
18556 +       %EM_TSESM_ESM(method=ADDSEASONAL,
18557 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18558 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18559 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18560 +       );
18561 +   %end;
18563 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
18565 +       %let n_model = %eval(&n_model+1);
18567 +       %let _ds_out =_out&n_model;
18568 +       %let _ds_outest =_outest&n_model;
18569 +       %let _ds_outfor =_outfor&n_model;
18570 +       %let _ds_outstat =_outstat&n_model;
18571 +       %let _ds_outsum=_outsum&n_model;
18573 +       %EM_TSESM_ESM(method=MULTSEASONAL,
18574 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18575 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18576 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18577 +       );
18578 +   %end;
18580 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
18582 +       %let n_model = %eval(&n_model+1);
18584 +       %let _ds_out =_out&n_model;
18585 +       %let _ds_outest =_outest&n_model;
18586 +       %let _ds_outfor =_outfor&n_model;
18587 +       %let _ds_outstat =_outstat&n_model;
18588 +       %let _ds_outsum=_outsum&n_model;
18590 +       %EM_TSESM_ESM(method=ADDWINTERS,
18591 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18592 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18593 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18594 +            );
18595 +   %end;
18598 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
18599 +   /*-------- end of seasonal model  ------------------------------------------------------*/
18601 +   %if &n_model eq 0 %then %do;
18603 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
18604 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
18605 +   %end;
18606 +   %else %do;
18607 +         %EM_TSESM_BestModelSel(crit=&criterion,
18608 +                               n_mdl=&n_model,
18609 +                               tsidvar=&tsidvar,
18610 +                               timeid=&timeid,
18611 +                               out=&outdata,
18612 +                               outest=&outest,
18613 +                               outfor =&outfor,
18614 +                               outstat=&outstat,
18615 +                               outsum=&outsum
18616 +                  );
18617 +   %end;
18619 +%mend EM_TSESM_Best_Forecast;
18622 +%macro EM_TSESM_ESM(method= ,
18623 +           timeinterval=,
18624 +           timeid= ,
18625 +           target= ,
18626 +           tsidvar=,
18627 +           lead=,
18628 +           back=,
18629 +           startsum=,
18630 +           accumulate=,
18631 +           seasonality=,
18632 +           alpha=,
18633 +           out= ,
18634 +           outest= ,
18635 +           outfor= ,
18636 +           outstat= ,
18637 +           outsum=
18638 +           );
18640 +       proc sort data= &_indata out=_tmpdata;
18641 +            by  &tsidvar %EM_CROSSID &timeid ;
18642 +       run;
18643 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
18645 +       %if &seasonality ne DEFAULT %then %do;
18646 +                     seasonality = &seasonality
18647 +       %end;
18648 +            out=&out
18649 +            outest=&outest
18650 +            outfor =&outfor
18651 +            outstat=&outstat
18652 +            outsum= &outsum
18653 +            ;
18654 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
18656 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18657 +            %if &target ne %then %do;
18658 +            forecast &target   /  model = none alpha=&alpha;
18659 +            %end;
18660 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18661 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
18662 +            %end;
18663 +       %end;
18664 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
18665 +            %if &target ne %then %do;
18666 +            forecast &target /  model =&method alpha=&alpha;
18667 +            %end;
18668 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18669 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
18670 +            %end;
18671 +       %end;
18672 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
18673 +            %if &target ne %then %do;
18674 +            forecast &target   /  model = &method alpha=&alpha;
18675 +            %end;
18676 +            /*
18677 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18678 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
18679 +            %end;
18680 +            */
18681 +       %end;
18683 +       %if &tsidvar ne %then %do;
18684 +        by &tsidvar %EM_CROSSID;
18685 +       %end;
18686 +       run;
18688 +%mend EM_TSESM_ESM;
18692 +%macro EM_TSESM_BestModelSel(crit=,
18693 +                    n_mdl=,
18694 +                    tsidvar=_TSID_,
18695 +                    timeid=MNTH_YR,
18696 +                    out=&_outdata,
18697 +                    outest=&_outest,
18698 +                    outfor =&_outfor,
18699 +                    outstat=&_outstat,
18700 +                    outsum=&_outsum
18701 +    );
18703 +   %let statbls=select *, 1 as mdlID from _outstat1;
18704 +   %let estbls=select *,  1 as mdlID from _outest1;
18705 +   %let fortbls=select *, 1 as mdlID from _outfor1;
18706 +   %let outbls=select *,  1 as mdlID from _out1;
18707 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
18708 +   %do i=2 %to &n_mdl;
18709 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
18710 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
18711 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
18712 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
18713 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
18714 +   %end;
18716 +   %let dsid=%sysfunc(open(_out1));
18717 +   %let vn_tsid = 0;
18719 +   %if &dsid > 0 %then %do;
18720 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18721 +         %let dsid = %sysfunc(close(&dsid));
18722 +   %end;
18724 +   %if &vn_tsid <= 0  %then %do;
18725 +       %let tsidvar=_NAME_;
18726 +   %end;
18728 +  /*
18729 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18730 +     %let tsidvar=_NAME_;
18731 +   %end;
18732 +  */
18734 +   proc sql;
18735 +     create table tsstat as &statbls;
18736 +     create table tsest  as &estbls;
18737 +     create table tsfor  as &fortbls;
18738 +     create table tsout  as &outbls;
18739 +     create table tssum  as &sumtbls;
18740 +   quit;
18742 +    proc sort data=tsstat out=bestmdl;
18743 +        by &tsidvar &crit mdlID;
18744 +    run;
18746 +    * when multiple BEST model found;
18747 +    * use the one with smallest model ID;
18748 +    data bestmdl;
18749 +        set bestmdl;
18750 +        by &tsIDvar;
18751 +        if first.&tsIDVar;
18752 +    run;
18754 +   proc sql;
18755 +      create table bestID as
18756 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
18757 +        from bestmdl,tsest
18758 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
18760 +      create table &outfor
18761 +        as select tsfor.*, _model_, &crit from tsfor, bestID
18762 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18764 +        create table &outstat
18765 +        as select tsstat.*, _model_ from tsstat, bestID
18766 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
18768 +        create table &outest
18769 +        as select tsest.*, &crit from bestmdl, tsest
18770 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
18772 +      create table &outsum
18773 +        as select tssum.*, _model_, &crit from tssum, bestID
18774 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
18776 +      /*
18777 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18778 +        create table &out
18779 +          as select tsout.*, _model_, &crit from tsout, bestID
18780 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18781 +      %end;
18782 +      */
18784 +      %if &tsidvar eq _TSID_ %then %do;
18786 +         create table &out
18787 +          as select tsout.*, _model_, &crit from tsout, bestID
18788 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18790 +      %end;
18791 + run;
18792 +quit;
18794 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
18796 + %if &tsidvar = _NAME_ %then %do;
18797 +      data
18798 +            %let i=1;
18799 +            %do i=1 %to &n_mdl;
18800 +               %let _tmpdsname = _tmpds&i;
18801 +                    &_tmpdsname
18802 +            %end;
18803 +        ;
18804 +         set work.Bestmdl;
18805 +            %let i=1;
18806 +            %do i=1 %to &n_mdl;
18807 +               %let _tmpdsname = _tmpds&i;
18808 +                  if mdlID = &i then output &_tmpdsname;
18809 +            %end;
18810 +      run;
18812 +      data &out;
18813 +           set _out1;
18814 +           keep &timeid %EM_TARGET;
18815 +      run;
18816 +      %let i=1;
18817 +      %do i=1 %to &n_mdl;
18818 +          %let _tmpdsname = _tmpds&i;
18819 +          %let _outdsname = _out&i;
18821 +          data &out;
18822 +               set &out;
18823 +               set &_outdsname(keep=
18824 +               %let dsid=%sysfunc(open(&_tmpdsname));
18825 +               %if &dsid > 0 %then %do;
18826 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
18827 +                  %do %while(^%sysfunc(fetch(&dsid)));
18828 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
18829 +                          &_name
18830 +                  %end;
18831 +                  %let dsid = %sysfunc(close(&dsid));
18832 +               %end;
18833 +               );
18834 +           run;
18835 +       %end;
18837 +%end;
18839 +data &out;
18840 +     set  &out;
18841 +      drop mdlID _MODEL_ &crit;
18842 +data &outest;
18843 +      set  &outest;
18844 +      drop mdlID &crit;
18845 +data &outfor;
18846 +     set &outfor;
18847 +     drop mdlID &crit;
18848 +data &outstat;
18849 +     set &outstat;
18850 +     drop mdlID;
18851 +data &outsum;
18852 +     set &outsum;
18853 +     drop mdlID &crit;
18854 +run;
18856 +%mend EM_TSESM_BestModelSel;
18860 +%macro EM_TSESM_MakeOutlierIndex(indata=,
18861 +                        target=,
18862 +                        timeid=,
18863 +                        outoutlier=,
18864 +                        outlierds=,
18865 +                        outdata=);
18866 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
18867 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
18868 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
18869 +data &outdata;
18870 +     set &indata;
18871 +     length OutlierIndex 8.;
18872 +     length Outlier  $40;
18873 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
18874 +     label  Outlier = "&label_Outlier";
18875 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
18876 +       else  do; OutlierIndex=0; outlier =" "; end; */
18877 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
18878 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
18879 +run;
18881 +data  &outoutlier;
18882 +      set  &outdata;
18883 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
18884 +      if ACTUAL = . then delete;
18885 +run;
18887 +data &outlierds;
18888 +     set &outoutlier;
18889 +     if OUTLIERINDEX = 0 then delete;
18890 +     Drop OUTLIERINDEX;
18891 +run;
18893 +%mend  EM_TSESM_MakeOutlierIndex;
18896 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
18897 +                         inoutlierds=,
18898 +                         target=,
18899 +                         timeid=,
18900 +                         tsidvar=_TSID_,
18901 +                         replace=,
18902 +                         outdata=);
18905 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
18908 +%let dsid=%sysfunc(open(&indata));
18909 +%let vn_tsid = 0;
18910 +%if &dsid > 0 %then %do;
18911 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18912 +         %let dsid = %sysfunc(close(&dsid));
18913 +%end;
18915 +%if &vn_tsid <= 0  %then %do;
18916 +    %let tsidvar=_NAME_;
18917 +%end;
18919 +%if &tsidvar = _TSID_ %then %do;
18920 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
18921 + /*    data &outdata;
18922 +          merge &indata &inoutlierds;
18923 +          by _TSID_ &timeid;
18924 +          if OutlierIndex > 0 then
18925 +          %if &replace eq PREDICT %then %do;
18926 +             &target = PREDICT;
18927 +          %end;
18928 +          %else %do;
18929 +             &target = .;
18930 +          %end;
18931 +           Drop Predict _NAME_ OutlierIndex;
18932 +     run;     */
18933 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
18934 +     %if &dsid > 0 %then %do;
18935 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
18936 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18937 +         %let i = 1;
18938 +              %do %while(^%sysfunc(fetch(&dsid)));
18939 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
18940 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
18941 +                  %if &i eq 1 %then %do;
18942 +                      data _tmpoutlier;
18943 +                           set &inoutlierds;
18944 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
18945 +                      run;
18946 +                      data &outdata;
18947 +                           merge &indata _tmpoutlier;
18948 +                           by _TSID_ &timeid ;
18949 +                           if OutlierIndex  > 0 then
18950 +                              %if &replace eq PREDICT %then %do;
18951 +                                &_varname = PREDICT;
18952 +                              %end;
18953 +                              %else %do;
18954 +                                &_varname = .;
18955 +                              %end;
18956 +                            Drop Predict _NAME_  OutlierIndex Outlier;
18957 +                      run;
18958 +                   %end;
18959 +                   %else %do;
18960 +                      data _tmpoutlier;
18961 +                           set &inoutlierds;
18962 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
18963 +                      run;
18964 +                      data &outdata;
18965 +                           merge &outdata _tmpoutlier;
18966 +                           by _TSID_ &timeid ;
18967 +                           if OutlierIndex  > 0 then
18968 +                              %if &replace eq PREDICT %then %do;
18969 +                                &_varname = PREDICT;
18970 +                              %end;
18971 +                              %else %do;
18972 +                                &_varname = .;
18973 +                              %end;
18974 +                           Drop Predict _NAME_  OutlierIndex Outlier;
18975 +                      run;
18976 +                   %end;
18977 +                   %let i = %eval(&i+1);
18979 +              %end;
18980 +           %let dsid = %sysfunc(close(&dsid));
18981 +      %end;
18982 +%end;
18983 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
18985 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
18986 +     %if &dsid > 0 %then %do;
18987 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
18988 +         %let i = 1;
18989 +              %do %while(^%sysfunc(fetch(&dsid)));
18990 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
18991 +                  %if &i eq 1 %then %do;
18992 +                      data _tmpoutlier;
18993 +                           set &inoutlierds;
18994 +                           if _NAME_ ="&_varname"  then output;
18995 +                      run;
18996 +                      data &outdata;
18997 +                           merge &indata _tmpoutlier;
18998 +                           by &timeid;
18999 +                           if OutlierIndex  > 0 then
19000 +                              %if &replace eq PREDICT %then %do;
19001 +                                &_varname = PREDICT;
19002 +                              %end;
19003 +                              %else %do;
19004 +                                &_varname = .;
19005 +                              %end;
19006 +                            Drop Predict _NAME_ OutlierIndex Outlier;
19007 +                      run;
19008 +                   %end;
19009 +                   %else %do;
19010 +                      data _tmpoutlier;
19011 +                           set &inoutlierds;
19012 +                           if _NAME_ ="&_varname"  then output;
19013 +                      run;
19014 +                      data &outdata;
19015 +                           merge &outdata _tmpoutlier;
19016 +                           by &timeid;
19017 +                           if OutlierIndex  > 0 then
19018 +                              %if &replace eq PREDICT %then %do;
19019 +                                &_varname = PREDICT;
19020 +                              %end;
19021 +                              %else %do;
19022 +                                &_varname = .;
19023 +                              %end;
19024 +                           Drop Predict _NAME_ OutlierIndex Outlier;
19025 +                      run;
19026 +                   %end;
19027 +                   %let i = %eval(&i+1);
19029 +              %end;
19030 +           %let dsid = %sysfunc(close(&dsid));
19031 +      %end;
19032 +      %else %do;
19033 +            /* this block is added 09022011*/
19034 +            /* works for wide table in which each time series has a column */
19036 +            proc transpose data=&indata out=_tmpdata1;
19037 +                by &timeID;
19038 +            run;
19040 +            proc sql;
19041 +                create table _tmpdata2 as
19042 +                    select a.*, b.outlierindex, b.outlier, b.predict
19043 +                        from _tmpdata1 as a left join &inoutlierds as b
19044 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
19045 +                        order by a.&timeID, a._name_
19046 +                    ;
19047 +            quit;
19049 +            data _tmpdata2;
19050 +                set _tmpdata2;
19051 +                if outlierindex eq 1 then
19052 +                    if &replace eq PREDICT then col1=predict; else col1=.;
19053 +            run;
19055 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
19056 +                by &timeID;
19057 +                ID _name_;
19058 +                var col1;
19059 +            proc sort data=&inoutlierds out=_tmpoutlier;
19060 +                by &timeID _name_;
19061 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
19062 +                by &timeID;
19063 +                ID _name_;
19064 +                var outlier;
19065 +            run;
19067 +            data &outdata;
19068 +                merge _tmpdata3 _tmpdata4;
19069 +                by &timeID;
19070 +            run;
19071 +      %end;
19072 +%end;
19073 +%mend EM_TSESM_MakeSmoothedOutds;
19075 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
19076 +                  insumdata=&EM_USER_OUTSUM,
19077 +                target=&_targetVar,
19078 +                timeid=&_timeidVar,
19079 +                futurepoint=1,
19080 +                outKLD=&EM_USER_OUTKLD
19081 +                );
19083 +%if &futurepoint > 0 %then %do;
19085 +proc sort data=&indata out=_tmptimeid;
19086 +     by &timeid;
19087 +run;
19089 +data _tmptimeid(keep=&timeid);
19090 +      set _tmptimeid; by &timeid;
19091 +      if first.&timeid then output;
19092 +run;
19094 +%let _targetTime =;
19095 +%let dsid=%sysfunc(open(work._tmptimeid));
19096 +%if &dsid > 0 %then %do;
19097 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
19098 +    %let i = 1;
19099 +    %do %while(^%sysfunc(fetch(&dsid)));
19100 +       %if &i eq &futurepoint %then %do;
19101 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
19102 +       %end;
19103 +       %let i = %eval(&i+1);
19104 +    %end;
19105 +    %let dsid = %sysfunc(close(&dsid));
19106 +%end;
19108 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
19109 +   set &indata;
19110 +   if &timeid eq &_targetTime then output;
19111 +run;
19113 +%end;  /* end of %if &futurepoint > 0 %then %do; */
19114 +%else %do;
19117 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
19118 +   set &insumdata;
19119 +run;
19122 +%end;
19124 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
19126 +/* Merge TSIDMAP  */
19128 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19129 +data &outKLD(rename=(_NAME_ =_NAMEID_));
19130 +       set &outKLD;
19131 +run;
19133 +%let dsid=%sysfunc(open(&outKLD));
19134 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
19135 +%let dsid=%sysfunc(close(&dsid));
19137 +%if &vn_name > 0 %then %do;
19138 +      data &outKLD(drop=_NAMEID_);
19139 +           merge &EM_USER_TSIDMAP &outKLD;
19140 +           by _TSID_;
19141 +      run;
19142 +%end;
19143 +%else %do;
19144 +      proc sort data= &outKLD; by _NAMEID_;
19145 +      run;
19146 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
19147 +      run;
19148 +      data &outKLD(drop=_NAMEID_);
19149 +           merge &EM_USER_TSIDMAP &outKLD;
19150 +           by _NAMEID_;
19151 +      run;
19152 +%end;
19154 +/* delete _tmptimeid  _tmpKLD */
19155 +%Mend  EM_TSESM_MakeOutKLD;
19158 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
19159 +                 target=&_targetVar,
19160 +                 timeid=&_timeidVar,
19161 +                 outdata=&EM_USER_OUTPRED
19162 +                 );
19164 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19165 +%let _EndTime = ;
19166 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19167 +%if &dsid > 0 %then %do;
19168 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19169 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
19170 +    %do %while(^%sysfunc(fetch(&dsid)));
19171 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19172 +       /*--------------------------------------------------------
19173 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
19174 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
19175 +        ---------------------------------------------------------*/
19176 +    %end;
19177 +    %let dsid = %sysfunc(close(&dsid));
19178 +%end;
19180 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
19181 +     set &indata;
19182 +     if &timeid > &_EndTime then output;
19183 +run;
19184 +%Mend  EM_TSESM_MakeOutPred;
19187 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
19189 +%let std_x = ;
19190 +%let mu_y = ;
19192 +%let dsid=%sysfunc(open(&indata));
19193 +%if &dsid > 0 %then %do;
19194 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
19195 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
19196 +    %let i=1;
19197 +    %do %while(^%sysfunc(fetch(&dsid)));
19198 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
19199 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
19200 +        %let _tsid = _TSID&i.;
19201 +        /* create new data set */
19202 +            %if &i = 1 %then %do;
19203 +            data _tmpindata;
19204 +                set &indata;
19205 +                  mu_x = &_pred;
19206 +                  std_x = &_std;
19207 +                  rename predict = mu_y;
19208 +                  rename std = std_y;
19209 +            run;
19210 +        data _tmpout;
19211 +                 set _tmpindata;
19212 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
19213 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
19214 +             &_tsid= (KLD1+KLD2)/2;
19215 +             if &_tsid < 0 then &_tsid = 0;
19216 +                   drop KLD1 KLD2;
19217 +         run;
19218 +             %end;
19219 +         %else %do;
19220 +         data _tmpindata;
19221 +                  set _tmpout;
19222 +                  mu_x = &_pred;
19223 +                  std_x = &_std;
19225 +             run;
19226 +         data _tmpout;
19227 +                 set _tmpindata;
19228 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
19229 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
19230 +             &_tsid= (KLD1+KLD2)/2;
19231 +             if &_tsid < 0 then &_tsid = 0;
19232 +                   drop KLD1 KLD2;
19233 +         run;
19235 +         %end;
19236 +             %let i = %eval(&i+1);
19238 +    %end;
19239 +    %let dsid = %sysfunc(close(&dsid));
19240 +    data &outdata;
19241 +         set _tmpout;
19242 +         drop mu_x mu_y std_x std_y;
19243 +    run;
19244 +%end;
19245 +%mend EM_TSESM_KLD;
19248 +%macro EM_TSESM_MakeOutClusInput(indata=,
19249 +                   target=,
19250 +                   timeid=,
19251 +                   tsidVar=,
19252 +                   percent=,
19253 +                   outlower=,
19254 +                   outupper=,
19255 +                   esmmethod=,
19256 +                   criterion=,
19257 +                   outdata=);
19259 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19261 +  data &outdata(rename=(_NAME_ =_NAMEID_));
19262 +       set &indata;
19263 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
19264 +  %if &esmmethod eq BEST %then %do;
19265 +      mdlID _MODEL_ &criterion
19267 +  %end;
19268 +  ;
19269 +  run;
19271 +  %let dsid=%sysfunc(open(&outdata));
19272 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
19273 +  %let dsid=%sysfunc(close(&dsid));
19275 +  %if &vn_name > 0 %then %do;
19276 +      proc sort data= &outdata; by _TSID_;
19277 +      run;
19278 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
19279 +      run;
19281 +      data &outdata(drop=_NAMEID_);
19282 +           merge &EM_USER_TSIDMAP &outdata;
19283 +           by _TSID_;
19284 +      run;
19285 +  %end;
19286 +  %else %do;
19287 +      proc sort data= &outdata; by _NAMEID_;
19288 +      run;
19289 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
19290 +      run;
19291 +      data &outdata(drop=_NAMEID_);
19292 +           merge &EM_USER_TSIDMAP &outdata;
19293 +           by _NAMEID_;
19294 +      run;
19295 +  %end;
19297 +%mend EM_TSESM_MakeOutClusInput;
19299 +%macro EM_TSESM_MakeOutSimInput(indata=,
19300 +                   inoutfor=,
19301 +                   target=,
19302 +                   timeid=,
19303 +                   tsidVar=,
19304 +                   esmmethod=,
19305 +                   criterion=,
19306 +                   outdata=);
19309 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19310 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19312 +   %let _EndTime = ;
19313 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
19314 +   %if &dsid > 0 %then %do;
19315 +   %let vn_end =%sysfunc(varnum(&dsid, END));
19316 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
19317 +   %do %while(^%sysfunc(fetch(&dsid)));
19318 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19319 +   %end;
19320 +   %let dsid = %sysfunc(close(&dsid));
19321 +   %end;
19323 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
19324 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
19326 +   data _out1;
19327 +       set &indata;
19328 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
19329 +           %tsesm_crossid
19330 +   %if &esmmethod eq BEST %then %do;
19331 +      mdlID _MODEL_ &criterion
19332 +   %end;
19333 +   ;
19334 +   run;
19336 +    %let dsid=%sysfunc(open(work._out1));
19337 +    %if &dsid > 0 %then %do;
19338 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
19339 +      %let dsid = %sysfunc(close(&dsid));
19340 +    %end;
19342 +    /*
19343 +    proc print data=_out1(obs=10);
19344 +    run;
19345 +    */
19346 +    %let _existtsid = Y;
19347 +    %if (&vn_tsid = 0)  %then %do;
19348 +    %let _existtsid = N;
19349 +    %goto NO_TSID_SIMINPUT;
19350 +    %end;
19352 +    data _out1;
19353 +        set _out1;
19354 +        where _name_ = "&target";
19355 +    run;
19356 +    %let target2 = &target._;
19357 +    proc transpose data=_out1 out=_out2 prefix=&target2;
19358 +            id _TSID_  ;
19359 +    run;
19360 +    /*
19361 +    proc print data=_out2(obs=11);
19362 +    run;
19363 +    */
19364 +    data _out2;
19365 +       length _index 8.;
19366 +       set _out2;
19367 +       _index=_N_;
19368 +       drop _NAME_ _LABEL_;
19369 +    run;
19372 +   data _out3;
19373 +       length _index 8.;
19374 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
19375 +         _index =_N_;
19376 +        keep &timeid _index;
19378 +   run;
19379 +   /*
19380 +   proc print data=_out2(obs=12);
19381 +   proc print data =_out3(obs=13);
19382 +   run;
19383 +   */
19384 +   data &outdata(drop=_index);
19385 +        merge _out3 _out2;by _index;
19386 +        run;
19389 +  proc transpose data=&outdata out=_tout;
19390 +     id &timeid;
19391 +   run;
19392 +   data _tout;
19393 +        length _TSID_ 8.;
19394 +        set _tout;
19395 +        rename _NAME_= _NAMEID_;
19396 +        _TSID_ = _N_;
19397 +        label _NAME_ = "NAMEID";
19398 +        keep _NAME_ _TSID_;
19400 +   run;
19402 +   data &EM_USER_TSIDMAP;
19403 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
19404 +   run;
19405 +   /*
19406 +   proc print data=_tout(obs=14);
19407 +   run;
19408 +   */
19409 +   proc datasets lib=work nolist;
19410 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
19411 +   run;
19414 +   %NO_TSID_SIMINPUT:
19415 +   %if  &_existtsid eq N %then %do;
19416 +   data &outdata;
19417 +        set &inoutfor(where=(&timeid > &_EndTime));
19418 +   run;
19419 +   %end;
19422 +%mend EM_TSESM_MakeOutSimInput;
19425 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
19426 +%do i=1 %to &nwherevalue;
19427 +     %if &i = 1 %then %do;
19428 +        data &outdata(drop = &wherevar);
19429 +             set &indata;
19430 +               if &wherevar= &i;
19431 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
19432 +               %else %let newname = &wherevar_&i;
19433 +                rename  &targetvar= &newname;
19434 +                   label &targetvar ="&targetvar._&i";
19435 +           run;
19436 +       %end;
19437 +       %else %do;
19438 +        data _tmp_out(drop = &wherevar);
19439 +             set &indata;
19440 +               if &wherevar= &i;
19441 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
19442 +               %else %let newname = &wherevar_&i;
19443 +                rename  &targetvar= &newname;
19444 +                   label &targetvar ="&targetvar._&i";
19445 +           run;
19446 +             data &outdata;
19447 +                  merge &outdata  _tmp_out; by &timeid;
19448 +         run;
19449 +       %end;
19450 +%end;
19452 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
19454 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
19456 +/*
19457 +       MACRO: TS Utility macros
19459 +       PURPOSE: TS Utility macros
19460 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
19462 +       HISTORY:
19463 +       NOTE:
19465 +*/
19467 +/*
19468 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
19469 +                          timeid=, timeformat=, timeinformat=);
19470 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
19472 +    %do;
19473 +    %let m_data      = &data;
19474 +    %let m_decdata   = &decdata;
19475 +    %let m_decmeta   = &decmeta;
19476 +    %let m_cmeta     = &cmeta;
19477 +    %let m_outfile   = &outfile;
19478 +    %let m_crossid   = &crossid;
19479 +    %let m_timeid    = &timeid;
19480 +    %let m_timeformat    = &timeformat;
19481 +    %let m_timeinformat    = &timeinformat;
19482 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
19483 +  %end;
19484 +%mend EM_TS_CreateTsMetaDs;
19485 +*/
19486 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
19487 +proc sql;
19488 +      create table _tmp_inds
19489 +      as select distinct &timeid from  &indata;
19490 +quit;
19491 +run;
19492 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
19493 +  id &timeid
19494 +%if &timeinterval ne %then %do;
19495 +    %if &timeformattype eq DATE %then %do;
19496 +        interval=&timeinterval
19497 +    %end;
19498 +    %else %if &timeformattype eq DATETIME  %then %do;
19499 +        %let dttimeinterval= DT&timeinterval;
19500 +         interval=&dttimeinterval
19501 +    %end;
19502 +%end;
19503 +;
19504 +run;
19506 +data &outds;
19507 +     set _tmp_tsmeta;
19508 +     format START &timeformat;
19509 +     format END &timeformat;
19510 +     length APPLY_START_END $8;
19511 +     APPLY_START_END ="No";
19512 +     FORMAT = "&timeformat";
19513 +     ROLE ="TIMEID";
19514 +     rename TIMEID = NAME;
19515 +     rename SEASONALITY= LengthOfCycle;
19516 +     rename INTERVAL = TIMEINTERVAL ;
19517 +     rename FORMAT = TIMEFORMAT;
19518 +     output;
19519 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
19520 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
19521 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
19522 +run;
19524 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
19525 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
19527 +%mend EM_TS_CreateTSMetaData;
19531 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
19533 +/* if updated = Y it will pass the TSMETA created by just the previous node */
19535 +%let _tsmetads = ;
19537 +%if &updated = Y %then %do;
19538 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
19539 +%if %sysfunc(exist(&_tsmetads)) %then %do;
19540 +%goto endline;
19541 +%end;
19542 +%end;
19544 +%if &eminfodata eq %then %do;
19545 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19546 +    data &EM_DATA_EMINFO;
19547 +         set &EM_IMPORT_DATA_EMINFO;
19548 +    run;
19549 +%end;
19550 +%else %do;
19551 +    %let dsid=%sysfunc(open(&eminfodata));
19552 +    data &EM_DATA_EMINFO;
19553 +         set &eminfodata;
19554 +    run;
19555 +%end;
19556 +%if &dsid > 0 %then %do;
19557 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
19558 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
19559 +    %do %while(^ %sysfunc(fetch(&dsid)));
19560 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19561 +         %if &_key eq TSMETA %then %do;
19562 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
19563 +         %end;
19564 +    %end;
19565 +    %let dsid = %sysfunc(close(&dsid));
19566 +%end; /* the end of %if &dsid > 0 %then %do; */
19568 +%endline:
19570 +%if &_tsmetads ne %then %do;
19571 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
19572 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19573 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
19574 +         data &EM_USER_TSMETA;
19575 +                   set &_tsmetads;
19576 +         run;
19577 +    %end;
19578 +%end;
19580 +*proc print data=&EM_DATA_EMINFO;
19581 +*proc print data=&EM_IMPORT_DATA_EMINFO;
19582 +*run;
19583 +%MEND EM_TS_GETTSMETA;
19586 +/*
19587 +%macro EM_GETTSMETAVARS(TimeInterval=);
19588 +%global &TimeInterval;
19589 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19590 +%if &dsid > 0 %then %do;
19591 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19592 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
19593 +%do %while(^ %sysfunc(fetch(&dsid)));
19594 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19595 +     %if &_role eq TIMEID %then %do;
19596 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19597 +     %end;
19598 +%end;
19599 +%let dsid = %sysfunc(close(&dsid));
19600 +%end;
19601 +%MEND EM_GETTSMETAVARS;
19602 +*/
19603 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
19604 +%global &TimeInterval;
19605 +%global &TimeId;
19606 +%global &EndTime;
19607 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19608 +proc print data=&EM_USER_TSMETA;
19609 +run;
19610 +%if &dsid > 0 %then %do;
19611 +%if &TimeInterval ne %then %do;
19612 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19613 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19614 +    %do %while(^ %sysfunc(fetch(&dsid)));
19615 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19616 +        %if &_role eq TIMEID %then %do;
19617 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19618 +        %end;
19619 +     %end;
19620 +%end;
19621 +%if &TimeId ne %then %do;
19622 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
19623 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19624 +    %do %while(^ %sysfunc(fetch(&dsid)));
19625 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19626 +        %if &_role eq TIMEID %then %do;
19627 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
19628 +        %end;
19629 +    %end;
19630 +%end;
19632 +%if &EndTime ne %then %do;
19633 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19634 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19635 +    %do %while(^ %sysfunc(fetch(&dsid)));
19636 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19637 +        %if &_role eq TIMEID %then %do;
19638 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19639 +        %end;
19640 +     %end;
19641 +%end;
19642 +%let dsid = %sysfunc(close(&dsid));
19643 +%end;
19644 +%MEND EM_TS_GETTSMETAVARS;
19648 +/*------------------------------------------------------------------
19650 +      Macro EM_GETTSIDMAP
19652 +------------------------------------------------------------------+*/
19655 +%macro EM_TS_GETTSIDMAP(updated=);
19657 +%let _tsidmap = ;
19659 +%if &updated = Y %then %do;
19660 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
19661 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19662 +%goto endline;
19663 +%end;
19664 +%end;
19666 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19667 +%if &dsid > 0 %then %do;
19668 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
19669 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19670 +%do %while(^ %sysfunc(fetch(&dsid)));
19671 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19672 +     %if &_key eq TSIDMAP %then %do;
19673 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
19674 +     %end;
19675 +%end;
19677 +%let dsid = %sysfunc(close(&dsid));
19678 +%end;
19680 +%endline:
19682 +%if &_tsidmap ne %then %do;
19684 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
19685 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19687 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19688 +         data &EM_USER_TSIDMAP;
19689 +               set &_tsidmap;
19690 +         run;
19691 +    %end;
19692 +%end;
19693 +%MEND EM_TS_GETTSIDMAP;
19695 +/*------------------------------------------------------------------*/
19700 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
19701 +%global &value;
19704 +%let dsid = %sysfunc(open(&data));
19705 +%if &dsid > 0 %then %do;
19706 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
19707 +    %if &vn_var < 1 %then %do;
19708 +        %let &value = 0;
19709 +        %let dsid = %sysfunc(close(&dsid));
19710 +        %goto endline;
19711 +    %end;
19712 +%let dsid = %sysfunc(close(&dsid));
19713 +%end;
19715 +%let _tmp=_tmpDS;
19716 +proc means data=&data &stat;
19717 +     var &var;
19718 +     output out=&_tmp;
19719 +run;
19721 +%let dsid = %sysfunc(open(&_tmp));
19722 +%if &dsid > 0 %then %do;
19723 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
19724 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
19725 +     %do %while(^%sysfunc(fetch(&dsid)));
19726 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
19727 +         %if &_stat eq &stat %then %do;
19728 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
19729 +          %end;
19730 +      %end;
19731 +%let dsid = %sysfunc(close(&dsid));
19732 +%end;
19733 +proc datasets lib=work nolist;
19734 + delete &_tmp;
19735 +run;
19736 +%endline:
19737 +%MEND EM_TS_GET_STAT;
19740 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
19741 +%global &format;
19742 +%global &informat;
19743 +%let dsid = %sysfunc(open(&data));
19744 +%if &dsid > 0 %then %do;
19745 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19746 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
19747 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
19748 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
19749 +%end;
19750 +%let dsid = %sysfunc(close(&dsid));
19751 +%end;
19752 +%MEND EM_TS_GET_VAR_FORMAT;
19754 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
19755 +      %if &lib eq %then %let lib=work;
19756 +       proc datasets lib=&lib nolist;
19757 +              delete &dsname;
19758 +       run;
19759 +%Mend  EM_TS_DELETE_DATA;
19762 +%macro EM_TS_GetNObs(inds=, nobs=);
19763 +    %global &nobs;
19764 +    %let &nobs=0;
19765 +    data _null_;
19766 +        set &inds end=eof;
19767 +        if eof then call symput("&nobs", _N_);
19768 +    run;
19769 +    quit;
19771 +    /*
19772 +    %let dsid=%sysfunc(open(&outdata));
19773 +    %if dsid > 0 %then %do;
19774 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
19775 +        %let dsid = %sysfunc(close(&dsid));
19776 +     %end;
19777 +    */
19778 +%mend  EM_TS_GetNObs;
19781 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
19782 +%global &time1;
19783 +%global &time2;
19784 +%if &default = Y %then %do;
19785 +   data _null_;
19786 +        set &data end=eof;
19787 +        if _N_ = 1 then  call symput("&time1", DATE);
19788 +        if eof then call symput("&time2", DATE);
19789 +    run;%end;
19790 +%else %do;
19791 +    %let dsid = %sysfunc(open(&data));
19792 +    %if &dsid > 0 %then %do;
19793 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
19794 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
19795 +        %do %while(^%sysfunc(fetch(&dsid)));
19796 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
19797 +             %if &_index eq 1 %then %do;
19798 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
19799 +             %end;
19800 +             %if &_index eq 2 %then %do;
19801 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
19802 +             %end;
19803 +        %end;
19804 +    %let dsid = %sysfunc(close(&dsid));
19805 +    %end;
19806 +%end;
19808 +%MEND EM_TS_GET_TIME_VALUES;
19810 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
19811 +%global &exist;
19812 + %let &exist = N;
19813 +%let dsid = %sysfunc(open(&data));
19814 +%if &dsid > 0 %then %do;
19815 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19816 +%if &vn_var > 0 %then %do;
19817 +    %let &exist = Y;
19818 +%end;
19819 +%let dsid = %sysfunc(close(&dsid));
19820 +%end;
19821 +%MEND EM_TS_GET_VAR_EXIST;
19824 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
19825 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
19826 +      set &intreedata;
19827 +        LENGTH NodeType $32;
19828 +      if _PARENT_ eq " " then delete;
19829 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
19830 +        else NodeType = "CLUSTER";
19831 +        LinkID = _N_;
19832 +run;
19833 +%Mend EM_TS_MakeConstellPlotData;
19838 +%macro EM_TS_CreateIDMap(
19839 +/*-------------------------------------------------------------------------*/
19840 +/*---   Written by Xiangxiang Meng                                         */
19841 +/*-------------------------------------------------------------------------*/
19842 +inDS          =,      /* imported data set in TS data mining               */
19843 +outIDMap      =,      /* output data set of TS ID map                      */
19844 +outDS         =,      /* output data set of TS and TS ID merged            */
19845 +variableSet   =,      /* EM variable set                                   */
19846 +TSIDbyCrossID =Y,
19847 +inEM          =Y
19848 +/*-------------------------------------------------------------------------*/
19849 +);
19851 +%global EM_TS_ERR;
19852 +%let EM_TS_ERR = 0;
19854 +%if &inEM eq Y %then %do;
19855 +    %let num_crossIDVar = &EM_NUM_CROSSID;
19856 +    proc sql noprint;
19857 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
19858 +    quit;
19859 +%end;
19860 +%else %do;
19861 +    proc sql noprint;
19862 +         select count(*) into :num_crossIDVar from &variableSet
19863 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19864 +         ;
19865 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
19866 +         ;
19867 +    quit;
19868 +    %let num_crossIDVar=&num_crossIDVar;
19869 +%end;
19871 +* see if _TSID_ exists;
19873 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
19874 +run;
19876 +proc sql noprint;
19877 +    select count(*) into :has_TSID
19878 +        from _emtscm_contents
19879 +        where upcase(strip(name)) eq '_TSID_'
19880 +    ;
19881 +quit;
19883 +/*-------------------------------------------------------------------------*/
19884 +* Creating TSID map..;
19885 +/*-------------------------------------------------------------------------*/
19887 +%if (&num_crossIDVar gt 0) %then %do;
19889 +    data _emtscm_tmpIDMap;
19890 +        set &variableSet;
19891 +        where  (upcase(strip(level)) eq 'INTERVAL')
19892 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19893 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19894 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19895 +          );
19896 +        _emts_dummy=1;
19897 +        keep name label role _emts_dummy;
19898 +    run;
19900 +    proc sql noprint;
19901 +        * create a string of crossID variable like A,B,C,D..;
19902 +        select distinct name into :crossIDVar separated by ','
19903 +            from &variableSet
19904 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19905 +            order by name
19906 +        ;
19907 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
19908 +            from &variableSet
19909 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19910 +            order by name
19911 +        ;
19912 +        * create the TSID map data set;
19913 +        create table _emtscm_tmp1 as
19914 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
19915 +        ;
19916 +        * create a level list of cross ID variables and time series variables;
19917 +        create table &outIDMap as
19918 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
19919 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
19920 +            where a._emts_dummy eq b._emts_dummy
19921 +            order by a.name, &crossIDVar
19922 +        ;
19923 +    quit;
19925 +    %if &TSIDbyCrossID = Y %then %do;
19926 +        * create unique TSID only by Cross ID;
19927 +        data &outIDMap;
19928 +            length _TSID_ 8;
19929 +            set &outIDMap;
19930 +            by _NAMEID_;
19931 +            if first._NAMEID_
19932 +                then _TSID_=1;
19933 +                else _TSID_+1;
19934 +        run;
19935 +        %if "&outDS" ne "" %then %do;
19936 +            * merge TSID into &inDS;
19937 +            proc sql noprint;
19938 +                create table &outDS as
19939 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
19940 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
19941 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
19942 +                        where %do i = 1 %to &num_crossIDVar;
19943 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
19944 +                              %end;
19945 +                             b._TSID_ is not missing
19946 +                    order by b._TSID_, a.&timeIDVar
19947 +                ;
19948 +            quit;
19949 +        %end;
19950 +    %end;
19951 +    %else %do;
19952 +        * create unique TSID by Cross ID and _NAMEID_;
19953 +        data &outIDMap;
19954 +            length _TSID_ 8;
19955 +            set &outIDMap;
19956 +            _TSID_=_n_;
19957 +        run;
19958 +        %if "&outDS" ne "" %then %do;
19959 +            *no merge in this output;
19960 +            data &outDS;
19961 +                set &inDS;
19962 +            run;
19963 +        %end;
19964 +    %end;
19966 +    proc sort data=&outIDMap;
19967 +        by _NAMEID_ _TSID_;
19968 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
19969 +        format _TSID_ best12. _NAMEID2_ $40.;
19970 +        set &outIDMap;
19971 +        by _NAMEID_;
19972 +        if first._NAMEID_
19973 +            then _emts_ind=1;
19974 +            else _emts_ind+1;
19975 +        drop _emts_ind;
19976 +        rename _NAMEID_=_VARNAME_;
19977 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
19978 +        if _labelID_ eq ' '
19979 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
19980 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
19981 +    run;
19983 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
19985 +%end;
19986 +%else %do; /* if no crossid's the nameid needs to be created */
19988 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
19989 +        length _TSID_ 8;
19990 +        set &variableSet;
19991 +        where  (upcase(strip(level)) eq 'INTERVAL')
19992 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19993 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19994 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19995 +          );
19996 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
19997 +        rename ROLE = _ROLE_;
19998 +        _NAMEID_=strip(name);
19999 +        _VARNAME_=strip(name);
20000 +        if label eq ' '
20001 +            then _LABELID_ = strip(name);
20002 +            else _LABELID_ = strip(label);
20003 +        _TSID_=_n_;
20004 +    run;
20006 +    %if "&outDS" ne "" %then %do;
20007 +        *no merge in this output;
20008 +        data &outDS;
20009 +            set &inDS;
20010 +        run;
20011 +    %end;
20012 +%end;
20014 +data &outIDMap;
20015 +    set &outIDMap;
20016 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
20017 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
20018 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
20019 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
20020 +run;
20022 +proc datasets lib=work nolist;
20023 +    delete _emtscm_:;
20024 +run; quit;
20026 +%mend EM_TS_createIDMap;
20028 +%macro EM_TS_CreateMetaData(
20029 +/*-------------------------------------------------------------------------*/
20030 +  inDS          =,      /* imported data set in TS data mining             */
20031 +  outDS         =,      /* output data set of TS metadata                  */
20032 +  variableSet   =,      /* EM variable set                                 */
20033 +  timeInterval  =,      /* time interval                                   */
20034 +  rc            =       /* return code                                     */
20035 +/*-------------------------------------------------------------------------*/
20036 +);
20038 +%if %eval(
20039 +      &EM_NUM_BINARY_INPUT   +
20040 +      &EM_NUM_ORDINAL_INPUT  +
20041 +      &EM_NUM_NOMINAL_INPUT  +
20042 +      &EM_NUM_BINARY_REJECTED   +
20043 +      &EM_NUM_ORDINAL_REJECTED  +
20044 +      &EM_NUM_NOMINAL_REJECTED  +
20045 +      &EM_NUM_ORDINAL_TARGET  +
20046 +      &EM_NUM_NOMINAL_TARGET +
20047 +      &EM_NUM_BINARY_TARGET
20048 +      ) > 0
20049 +%then %do;
20050 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
20051 +        %put &em_codebar;
20052 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
20053 +        %put &errormsg;
20054 +        %put &em_codebar;
20055 +        %goto ENDLINE;
20056 +%end;
20058 +%global EM_TS_ERR;
20059 +%let EM_TS_ERR = 0;
20061 +%if &timeInterval eq AUTO
20062 +    %then %let timeInterval  = ;
20063 +    %else %let timeInterval  = %upcase(&timeInterval);
20065 +/*-------------------------------------------------------------------------*/
20066 +* check time ID variable;
20067 +/*-------------------------------------------------------------------------*/
20069 +* number of variables in the Variableset with ROLE=TIMEID;
20070 +proc sql noprint;
20071 +    select count(*) into :num_timeID from &variableset
20072 +        where upcase(role) eq 'TIMEID';
20073 +quit;
20075 +/*-------------------------------------------------------------------------*/
20076 +* process only when there is one Time ID, otherwise exception message;
20077 +/*-------------------------------------------------------------------------*/
20079 +%if &num_timeID eq 0 %then %do;
20081 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
20082 +    %let EM_TS_ERR = 11;
20083 +    %put &em_codebar;
20084 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
20085 +    %put &errormsg;
20086 +    %put &em_codebar;
20087 +    %goto tscm_endline;
20089 +%end;
20090 +%else %if &num_timeID gt 1 %then %do;
20092 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
20093 +    %let EM_TS_ERR = 12;
20094 +    %put &em_codebar;
20095 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
20096 +    %put &errormsg;
20097 +    %put &em_codebar;
20098 +    %goto tscm_endline;
20100 +%end;
20101 +%else %do;
20102 +    *** proceed when there is one Time ID;
20104 +    data _null_;
20105 +        set &variableset(where=(upcase(role)='TIMEID'));
20106 +        call symput('timeIDFormat',     strip(format));
20107 +        call symput('timeID',           strip(upcase(name)      ));
20108 +        call symput('timeIDLevel',      strip(upcase(level))     );
20109 +        call symput('timeIDFormatType', strip(upcase(formattype)));
20110 +    run;
20112 +    *** exception message if the time ID is not an interval variable;
20113 +    %if &timeIDLevel ne INTERVAL %then %do;
20114 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
20115 +        %let EM_TS_ERR = 13;
20116 +        %put &em_codebar;
20117 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
20118 +        %put &errormsg;
20119 +        %put &em_codebar;
20120 +        %goto tscm_endline;
20121 +    %end;
20123 +    %if (&timeIDFormatType ne DATETIME) and
20124 +        (&timeIDFormatType ne DATE) and
20125 +        (&timeIDFormatType ne TIME) and
20126 +        (&timeIDFormatType ne USER)
20127 +    %then %do;
20128 +        *** sequential format-type of time ID;
20130 +        %let timeInterval = DAY;
20131 +        %let timeIDFormatType = SEQ;
20133 +        proc sql noprint;
20134 +            create table _emtscm_inds as
20135 +                 select distinct &timeID from &inDS(keep=&timeID)
20136 +                 where &timeID is not missing;
20137 +            select count(*) into :num_nonInteger from _emtscm_inds
20138 +                where &timeID ne int(&timeID);
20139 +        quit;
20141 +        %if &num_nonInteger gt 0 %then %do;
20142 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
20143 +            %let EM_TS_ERR = 14;
20144 +            %put &em_codebar;
20145 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
20146 +            %put &errormsg;
20147 +            %put &em_codebar;
20148 +            %goto tscm_endline;
20149 +        %end;
20150 +    %end;
20151 +    %else %do;
20152 +        *** date, datetime, time format-type of time ID;
20154 +        *** must have a format;
20155 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
20156 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
20157 +            %let EM_TS_ERR = 15;
20158 +            %put &em_codebar;
20159 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
20160 +            %put &errormsg;
20161 +            %put &em_codebar;
20162 +            %goto tscm_endline;
20163 +        %end;
20165 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
20166 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
20167 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
20168 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
20169 +                %let EM_TS_ERR = 16;
20170 +                %put &em_codebar;
20171 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
20172 +                %put &errormsg;
20173 +                %put &em_codebar;
20174 +                %goto tscm_endline;
20175 +            %end;
20176 +        %end;
20178 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
20179 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
20180 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
20181 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
20182 +                %let EM_TS_ERR = 17;
20183 +                %put &em_codebar;
20184 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
20185 +                %put &errormsg;
20186 +                %put &em_codebar;
20187 +                %goto tscm_endline;
20188 +            %end;
20189 +        %end;
20191 +        *** the AUTO function is currently turned off for TIME timeID variable;
20192 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
20193 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
20194 +            %let EM_TS_ERR = 18;
20195 +            %put &em_codebar;
20196 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
20197 +            %put &errormsg;
20198 +            %put &em_codebar;
20199 +            %goto tscm_endline;
20200 +        %end;
20202 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
20203 +            %then %let timeInterval =DT&timeInterval;
20205 +        proc sql noprint;
20206 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
20207 +                where &timeID is not missing;
20208 +        quit;
20209 +    %end;
20211 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
20212 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
20213 +    run;
20215 +    %let hasValidInterval = 0;
20216 +    %let hasLengthOne     = 0;
20218 +    proc sql noprint;
20219 +        create table _emtscm_label as
20220 +            select name,label
20221 +            from dictionary.columns
20222 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
20223 +        ;
20224 +        create table _emtscm_meta2 as
20225 +            select a.*, b.label
20226 +            from _emtscm_meta as a, _emtscm_label as b
20227 +            where upcase(a.timeID) eq upcase(b.name)
20228 +        ;
20229 +    quit;
20231 +    data &outDS;
20232 +        set _emtscm_meta2;
20233 +        format
20234 +            timeformat      $30.
20235 +            role            $10.
20236 +            start           &timeIDformat
20237 +            end             &timeIDformat
20238 +            apply_start_end $8.
20239 +        ;
20240 +        rename
20241 +            timeID      = name
20242 +            seasonality = lengthOfCycle
20243 +            interval    = timeinterval
20244 +        ;
20245 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
20247 +        role            = "TIMEID";
20248 +        apply_start_end = 'N';
20249 +        timeformat      = symget('timeIDformat');
20250 +        timeformattype  = symget('timeIDformatType');
20252 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
20253 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
20254 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
20255 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
20256 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
20257 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
20258 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
20259 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
20260 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
20261 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
20263 +        if timeformattype eq 'SEQ' then do;
20264 +            timeformat='BEST12.';
20265 +            seasonality=1;
20266 +        end;
20268 +        call symput('_tinterval',interval);
20270 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
20272 +        if upcase(timeformattype) eq 'DATE' and
20273 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
20274 +            then call symput('hasValidInterval',1);
20276 +        if upcase(timeformattype) eq 'DATETIME' and
20277 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
20278 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
20279 +            then call symput('hasValidInterval',1);
20281 +        if upcase(timeformattype) eq 'TIME' and
20282 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
20283 +            then call symput('hasValidInterval',1);
20285 +        if upcase(timeformattype) eq 'SEQ'
20286 +            then call symput('hasValidInterval',1);
20288 +        if upcase(timeformattype) eq 'USER'
20289 +            then call symput('hasValidInterval',1);
20291 +        if start eq end
20292 +            then call symput('hasLengthOne',1);
20293 +    run;
20295 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
20297 +    *** detect any missing time interval after running PROC TIMEID;
20298 +    %if &_tinterval eq %then %do;
20299 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
20300 +        %let EM_TS_ERR = 19;
20301 +        %put &em_codebar;
20302 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
20303 +        %put &errormsg;
20304 +        %put &em_codebar;
20305 +        %goto tscm_endline;
20306 +    %end;
20308 +    *** detect any missing time interval after running PROC TIMEID;
20309 +    %if &hasValidInterval eq 0 %then %do;
20310 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
20311 +        %let EM_TS_ERR = 20;
20312 +        %put &em_codebar;
20313 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
20314 +        %put &errormsg;
20315 +        %put &em_codebar;
20316 +        %goto tscm_endline;
20317 +    %end;
20319 +    %if &hasLengthOne eq 1 %then %do;
20320 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
20321 +        %let EM_TS_ERR = 21;
20322 +        %put &em_codebar;
20323 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
20324 +        %put &errormsg;
20325 +        %put &em_codebar;
20326 +        %goto tscm_endline;
20327 +    %end;
20329 +%end;
20331 +%tscm_endline:;
20333 +%mend EM_TS_CreateMetaData;
20336 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
20338 +data _null_;
20339 +    set &tsmeta;
20340 +    call symput('_timeidFormatType', timeformattype);
20341 +    call symput('_timeid', strip(name));
20342 +    call symput('_seqstartnum',strip(put(start,best12.)));
20343 +run;
20345 +proc contents data=&inDS noprint
20346 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20347 +run; quit;
20349 +data _null_;
20350 +    set _emts_tmpp1;
20351 +    call symput('_timeIDlabel',label);
20352 +run;
20354 +%if &_timeidFormatType eq SEQ
20355 +%then %do;
20356 +    proc sql noprint;
20357 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
20358 +    quit;
20359 +    %let _dummystarttime=&_dummystarttime;
20361 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20362 +        set &inDS;
20363 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
20364 +        drop &_timeid;
20365 +        label _tsdp_tmpID = "&_timeIDlabel";
20367 +    run;
20368 +%end;
20370 +%mend;
20372 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
20374 +data _null_;
20375 +    set &tsmeta;
20376 +    call symput('_timeidFormatType', timeformattype);
20377 +    call symput('_timeidFormat', timeformat);
20378 +    call symput('_timeid', strip(name));
20379 +    call symput('_timeinterval',strip(upcase(timeinterval)));
20380 +run;
20382 +/* manually change time ID format to a longer enough time format */
20383 +/* because proc timeid returns time5. for second time interval */
20384 +/* which is not long enough for transpose with time unit as seconds */
20385 +%if &_timeinterval eq SECOND
20386 +%then %do;
20387 +    %let _timeIDformat = %str(time8.);
20388 +%end;
20390 +proc contents data=&inDS noprint
20391 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20392 +run; quit;
20394 +data _null_;
20395 +    set _emts_tmpp1;
20396 +    call symput('_timeIDlabel',label);
20397 +run;
20399 +%if &_timeidFormatType eq TIME
20400 +%then %do;
20401 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20402 +        set &inDS;
20403 +        _tsdp_tmpID = timepart(&_timeID);
20404 +        format _tsdp_tmpID &_timeidFormat;
20405 +        label  _tsdp_tmpID = "&_timeIDlabel";
20406 +        drop &_timeid;
20407 +    run;
20408 +%end;
20410 +%mend;
20412 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
20414 + proc sql noprint;
20415 +     create table _tmptimetable as
20416 +         select distinct &timeidvar as DATE from &inDS
20417 +         where &timeIDVar is not missing
20418 +         order by &timeIDVar;
20419 + quit;
20421 +%if &compare eq Y %then %do;
20422 +    * compare with the existing time table;
20423 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
20424 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
20425 +    run;
20427 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
20429 +    %if &_diffobs > 0 %then %do; /* create it again */
20430 +        data &outDS(keep=DATE _INDEX_);
20431 +            set _tmptimetable end = _eof_;
20432 +            if _N_ = 1
20433 +                then _INDEX_ = 1;
20434 +                else _INDEX_ = 0;
20435 +            if _eof_ then _INDEX_= 2;
20436 +        run;
20437 +    %end;
20439 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
20440 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20441 +%end;
20442 +%else %do;
20443 +    * create a new time table directly;
20444 +    data &outDS(keep=DATE _INDEX_);
20445 +        set _tmptimetable end = _eof_;
20446 +        if _N_ = 1
20447 +            then _INDEX_ = 1;
20448 +            else _INDEX_ = 0;
20449 +        if _eof_ then _INDEX_= 2;
20450 +    run;
20452 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20453 +%end;
20455 +* assign a defult format BEST12. for sequential time ID;
20457 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
20459 +%let _nodatefmt=N;
20461 +data _null_;
20462 +    set _tmpcontents;
20463 +    where upcase(name) eq 'DATE';
20464 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
20465 +run;
20467 +%if "&_nodatefmt" eq "Y" %then %do;
20468 +    data &outDS;
20469 +        set &outDS;
20470 +        format date best12.;
20471 +    run;
20472 +%end;
20474 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
20476 +%mend;
20480 +%macro EM_TS_Transpose(
20481 +/*-------------------------------------------------------------------------*/
20482 +  inDS          =,      /* imported data set in TS data mining             */
20483 +  inIDMap       =,      /* input TS ID map                                 */
20484 +  variableSet   =,      /* variable set                                    */
20485 +  transposeBy   =,      /* byTSID or byTimeID                              */
20486 +  outDS         =,      /* output transposed data set                      */
20487 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
20488 +  inEM          =Y,
20489 +  timePrefix    =_T
20490 +/*-------------------------------------------------------------------------*/
20491 +);
20493 +%let timePrefix = &timePrefix;
20495 +%if  &EM_NUM_CROSSID > 0 %then %do;
20497 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
20498 +    set &inIDMap;
20499 +    drop _NAMEID_;
20500 +    run;
20501 +%let inIDMap=_emtstp_map0;
20503 +%end;
20505 +proc sql noprint;
20506 +    * number of TS Variables to be transposed;
20507 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
20508 +    ;
20509 +    * number of TS Variables to be transposed;
20510 +    select max(_TSID_) into :num_TSID from &inIDMap
20511 +    ;
20512 +    * name list of TS Variables;
20513 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
20514 +        from &inIDMap
20515 +        order by _NAMEID_
20516 +    ;
20517 +    * total number of time series =max(_TSID_)*&num_TSVar;
20518 +    * and the number of digits of this variable is &num_digits;
20519 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
20520 +        from &inIDMap
20521 +    ;
20522 +      * Time ID variable;
20523 +    select name into:timeIDVar from &variableset
20524 +        where upcase(role) eq 'TIMEID'
20525 +    ;
20526 +quit;
20527 +%let num_digits = &num_digits;
20528 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
20530 +/*-------------------------------------------------------------------------*/
20532 +* get number of cross IDs and also the TIME ID variable name;
20533 +%if &inEM eq Y %then %do;
20534 +    %let num_crossIDVar = &EM_NUM_CROSSID;
20535 +    %let crossIDVar     = %EM_CROSSID;
20536 +%end;
20537 +%else %do;
20538 +    proc sql noprint;
20539 +        * number of cross ID;
20540 +        select count(*) into :num_crossIDVar
20541 +            from &variableSet
20542 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20543 +        ;
20544 +        * create a string of crossID variable like A B C D..;
20545 +        select distinct name into :crossIDVar separated by ' '
20546 +            from &variableSet
20547 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20548 +            order by name
20549 +        ;
20550 +    quit;
20551 +    %let num_crossIDVar=&num_crossIDVar;
20552 +%end;
20554 +/*-------------------------------------------------------------------------*/
20556 +%if (&num_crossIDVar gt 0) %then %do;
20558 +    data _emtstp_tmpDat;
20559 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
20560 +        _NAMEID_ = cats("_TS_",_TSID_);
20561 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
20562 +    run;
20564 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20566 +        * update the ID maps;
20567 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20568 +            by _NAMEID_ _TSID_;
20569 +        data &outIDMap;
20570 +            set _emtstp_tmpmap;
20571 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20572 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20573 +        run;
20575 +        * get the names for the new variables;
20576 +        proc sql noprint;
20577 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
20578 +            ;
20579 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
20580 +            ;
20581 +        quit;
20583 +        * data must be sorted before transposed;
20584 +        proc sort data=_emtstp_tmpDat;
20585 +            by &timeIDvar;
20586 +        run;
20588 +        %do i = 1 %to &num_TSVar;
20589 +            %let i = &i;
20590 +            * transpose one cross-type time series data by TSID;
20591 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
20592 +                id _NAMEID_;
20593 +                by &timeIDVar;
20594 +                var &&&TSVar&i;
20595 +            run;
20596 +        %end;
20598 +        * merge all vertical time series, rename and label them;
20599 +        data &outDS;
20600 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
20601 +            by &timeIDVar;
20602 +            rename
20603 +                %do i = 1 %to &num_TSVar;
20604 +                    %do j = 1 %to &num_TSID;
20605 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20606 +                        /* %put &i &j &num1 &num_TSID; */
20607 +                        _V_&i._TS_&j = &&&tsname&num1
20608 +                    %end;
20609 +                %end;
20610 +            ;
20611 +            label
20612 +                %do i = 1 %to &num_TSVar;
20613 +                    %do j = 1 %to &num_TSID;
20614 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20615 +                        /* %put &i &j &num1 &num_TSID; */
20616 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
20617 +                    %end;
20618 +                %end;
20619 +            ;
20620 +        run;
20621 +    %end;
20622 +    %else %do;
20624 +        * update the ID maps;
20625 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20626 +            by _NAMEID_ _TSID_;
20627 +        data &outIDMap;
20628 +            set _emtstp_tmpmap;
20629 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20630 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20631 +        run;
20633 +        proc sql noprint;
20634 +            * get the roles for the new variables;
20635 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
20636 +                from &inIDMap
20637 +                order by _NAMEID_
20638 +            ;
20639 +            * get the length of the time series;
20640 +            select count(distinct &timeIDvar) into :num_T
20641 +                from _emtstp_tmpDat
20642 +            ;
20643 +        quit;
20645 +        * data must be sorted before transposed;
20646 +        proc sort data=_emtstp_tmpDat;
20647 +            by _TSID_ &crossIDVar &timeIDvar;
20648 +        run;
20650 +        %do i = 1 %to &num_TSVar;
20651 +            %let i = &i;
20652 +            * transpose one cross-type time series data by TIMEID;
20653 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
20654 +                by _TSID_ &crossIDVar;
20655 +                var &&&TSVar&i;
20656 +            run;
20657 +        %end;
20659 +        * stack all horizontal time series;
20660 +        data &outDS;
20661 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
20662 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
20663 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
20664 +            %do i=1 %to &num_TSVar;
20665 +                if in&i then do;
20666 +                    _NAMEID_ ="&&&TSVar&i";
20667 +                    _ROLE_   ="&&&TSRole&i";
20668 +                end;
20669 +            %end;
20670 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
20671 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
20672 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
20673 +        run;
20674 +    %end;
20675 +%end;
20676 +%else %do;
20678 +    proc sql noprint;
20679 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
20680 +            order by _NAMEID_
20681 +        ;
20682 +    quit;
20684 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20685 +        * transpose the panel-type time series data by TSID;
20686 +        proc sort data=&inDS out=_emtstp_tmpDat;
20687 +            by &timeIDvar;
20688 +        proc transpose data=_emtstp_tmpDat
20689 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
20690 +            by &timeIDVar;
20691 +            var &panelTSVar;
20692 +        run;
20693 +        proc datasets lib=work nolist;
20694 +            modify _emtstp_tmpDat2;
20695 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
20696 +            run; quit;
20697 +    %end;
20698 +    %else %do;
20699 +        * transpose the panel-type time series data by TIMEID;
20700 +        proc sort data=&inDS out=_emtstp_tmpDat;
20701 +            by &timeIDvar;
20702 +        data _emtstp_tmpDat;
20703 +            set _emtstp_tmpDat;
20704 +            _tmp_ind=_n_;
20705 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
20706 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
20707 +            ID _tmp_ind;
20708 +            var &panelTSVar;
20709 +        run;
20710 +    %end;
20712 +      * merge ID maps to the transpose data set;
20713 +      proc sql noprint;
20714 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
20715 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
20716 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
20717 +          ;
20718 +      quit;
20720 +      * update the TS ID map;
20721 +      data &outIDMap;
20722 +          set &inIDMap;
20723 +      run;
20724 +%end;
20726 +proc datasets lib=work nolist;
20727 +    delete _emtstp:;
20728 +run; quit;
20730 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_SCORE.SOURCE.
20732 +/*----------------------------------------------------------------------------------+
20733 + |
20734 + |   Title :  TS ESM Node
20735 + |
20736 + |   SUPPORT: Taiyeong Lee (Taiyeong.Lee@sas.com)
20737 + |
20738 + +-----------------------------------------------------------------------------------*/
20740 +%macro EM_TSESM_SCORE;
20742 +    /* the case when Targets and Inputs have the same format, apply the format to the output statistics*/
20743 +    /* defect S1014292 */
20744 +    %global  _seriesFormat;
20745 +    %let _seriesFormat =;
20746 +    proc sql noprint;
20747 +        select count(distinct format) into :_numSeriesFormat
20748 +        from &EM_DATA_VARIABLESET
20749 +        where upcase(role) eq 'TARGET' or upcase(role) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D');
20750 +    quit;
20751 +    %if &_numSeriesFormat = 1 %then %do;
20752 +        proc sql noprint;
20753 +            select distinct format into :_seriesFormat
20754 +            from &EM_DATA_VARIABLESET
20755 +            where upcase(role) eq 'TARGET' or upcase(role) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D');
20756 +        quit;
20757 +    %end;
20759 +   /* When Forecast Input Time Series is Yes, Output Data Type is always Default */
20760 +   %let _EXPORTDATA = &EM_PROPERTY_EXPORTDATA;
20761 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
20762 +      %let _EXPORTDATA = DEFAULT  ;
20763 +   %end;
20766 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
20767 +    %EM_GETNAME(KEY=FORCSTPLOTDS, TYPE=DATA);
20770 +%if &EM_PROPERTY_PLOTLENGTH ne MAX %then %do;
20773 +    %if &EM_PROPERTY_PLOTLENGTH eq DEFAULT %then %do;
20774 +        %let _nobs = 0;
20775 +        %let dsid=%sysfunc(open(&EM_USER_OUTFORCST));
20776 +        %if dsid > 0 %then %do;
20777 +            %let _nobs = %sysfunc(attrn(&dsid, NOBS));
20778 +            %let dsid = %sysfunc(close(&dsid));
20779 +        %end;
20781 +        %if &_nobs > 20000 %then %let _PLOTLENGTH = 3;
20782 +        %else %let _PLOTLENGTH = MAX;
20784 +    %end;
20785 +    %else %do;
20786 +        %let _PLOTLENGTH = &EM_PROPERTY_PLOTLENGTH;
20787 +    %end;
20789 +    %if &_PLOTLENGTH ne MAX %then %do;
20790 +         %let _timeidvar =%EM_TIMEID;
20791 +         data _tmptimeds;
20792 +            set   &EM_USER_OUTFORCST ;
20793 +            keep=&_timeidvar;
20794 +         run;
20795 +         proc sql;
20796 +              create table _tmptimeds2
20797 +              as
20798 +             select distinct(_tmptimeds.&_timeidvar) from _tmptimeds;
20799 +         run;
20800 +         quit;
20802 +         proc sort data=_tmptimeds2   out= _tmptimeds2  ;
20803 +              by descending &_timeidvar;
20804 +         run;
20805 +         %let _nplot =%sysevalf(&EM_PROPERTY_FCLEAD * (1+ &_PLOTLENGTH));
20807 +         %let _ntimeid = 0;
20808 +         %let dsid=%sysfunc(open(work._tmptimeds2));
20809 +         %if dsid > 0 %then %do;
20810 +             %let _ntimeid = %sysfunc(attrn(&dsid, NOBS));
20811 +             %let dsid = %sysfunc(close(&dsid));
20812 +         %end;
20813 +         %if &_ntimeid > &_nplot %then %do;
20814 +             data _null_;
20815 +                 set _tmptimeds2;
20816 +                 if _N_ eq &_nplot then do;
20817 +                 call symput("_start", &_timeidvar);
20818 +                 end;
20819 +             run;
20821 +             data &EM_USER_FORCSTPLOTDS;
20822 +               set  &EM_USER_OUTFORCST;
20823 +               if &_timeidvar >= &_start then output;
20824 +             run;
20825 +         %end;
20826 +         %else %do;
20827 +               data &EM_USER_FORCSTPLOTDS;
20828 +                    set  &EM_USER_OUTFORCST;
20829 +               run;
20830 +         %end;
20831 +    %end; /* end of %if &_PLOTLENGTH ne MAX %then %do; */
20832 +    %else %do;
20833 +         data &EM_USER_FORCSTPLOTDS;
20834 +              set  &EM_USER_OUTFORCST;
20835 +         run;
20836 +    %end;
20838 +%end; /* end of ne MAX */
20839 +%else %do;
20840 +    data &EM_USER_FORCSTPLOTDS;
20841 +         set  &EM_USER_OUTFORCST;
20842 +    run;
20843 +%end;  /* end of eq Max  */
20845 +/* Apply series format */
20846 +    /* defect S1014292 */
20847 +%if &_seriesFormat ^= %then %do;
20849 +    data &EM_USER_FORCSTPLOTDS;
20850 +         set  &EM_USER_FORCSTPLOTDS;
20851 +         format ACTUAL &_seriesFormat;
20852 +         format PREDICT &_seriesFormat;
20853 +         format LOWER &_seriesFormat;
20854 +         format UPPER &_seriesFormat;
20855 +         format ERROR &_seriesFormat;
20856 +         format STD &_seriesFormat;
20857 +    run;
20860 +%end;
20862 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptimeds);
20863 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptimeds2);
20867 +/* moved from training macro by ruzhan */
20869 +   %EM_GETNAME(KEY=OUTPRED, TYPE=DATA);
20870 +   %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
20871 +   %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
20872 +   %EM_GETNAME(KEY=OUTLIER, TYPE=DATA);
20873 +   %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
20874 +   %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
20876 +/* Apply series format */
20877 +    /* defect S1014292 */
20878 +%if &_seriesFormat ^= %then %do;
20880 +    data &EM_USER_OUTSUM;
20881 +        set  &EM_USER_OUTSUM;
20882 +        format MIN &_seriesFormat;
20883 +        format MAX &_seriesFormat;
20884 +        format MEAN &_seriesFormat;
20885 +        format STDDEV &_seriesFormat;
20886 +        format PREDICT &_seriesFormat;
20887 +        format LOWER &_seriesFormat;
20888 +        format UPPER &_seriesFormat;
20889 +        format STD &_seriesFormat;
20890 +        %let _lead_num_ = 1;
20891 +        %do %while (&_lead_num_ <= &em_property_FCLead);
20892 +            %let _FCLead_ = _LEAD&_lead_num_._;
20893 +            format &_FCLead_ &_seriesFormat;
20894 +            %let _lead_num_ = %eval(&_lead_num_ +1);
20895 +        %end;
20897 +    run;
20900 +%end;
20903 +   /*---------- Check and assign the input data set --------------------------*/
20906 +    %let _EXPORT_DATA  = ;
20907 +    %let _FILE_CDELTA  = ;
20909 +    %if &EM_IMPORT_DATA ne  %then %do;
20911 +           %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
20912 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
20914 +    %end;
20915 +    %else %if &EM_IMPORT_TRANSACTION ne  %then %do;
20917 +           %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
20918 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRANSACTION;
20919 +    %end;
20920 +    %else %do;
20921 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
20922 +           %goto ENDLINE;
20923 +    %end;
20927 +   %if &_EXPORTDATA eq KLD %then %do;
20928 +       %if  &EM_PROPERTY_CLUSLEADPOINT > %eval(&EM_PROPERTY_FCLEAD-&EM_PROPERTY_FCBACK) %then %do;
20929 +           %put &em_codebar;
20930 +           %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.invalidleadpointforkld_err, NOQUOTE));
20931 +           %put &errormsg;
20932 +           %put &em_codebar;
20933 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidleadpointforkld;
20934 +           %goto ENDLINE;
20935 +       %end;
20936 +       %else %do;
20937 +            %let _clusLeadPoint =  &EM_PROPERTY_CLUSLEADPOINT;
20938 +       %end;
20939 +       %EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
20940 +                            target=%EM_TARGET,
20941 +                            timeid=%EM_TIMEID,
20942 +                            futurepoint=&_clusLeadPoint,
20943 +                            outKLD=&EM_USER_OUTKLD
20944 +                            );
20946 +       data &_EXPORT_DATA;
20947 +           set &EM_USER_OUTKLD;
20948 +       run;
20949 +   %end;
20950 +    %else %if &_EXPORTDATA eq FORECAST %then %do;
20952 +              %EM_TSESM_MakeOutClusInput(indata=&EM_USER_OUTSUM,
20953 +                                         esmmethod=&EM_PROPERTY_FCMETHOD,
20954 +                                         criterion=&EM_PROPERTY_BESTCRIT,
20955 +                                         outdata= &_EXPORT_DATA);
20956 +    %end;
20957 +    %else %if &_EXPORTDATA eq SIMILARITY %then %do;
20959 +              %EM_TSESM_MakeOutSimInput(indata=&EM_USER_OUTSUM,
20960 +                                        inoutfor=&EM_USER_OUTDATA,
20961 +                                        target=%EM_TARGET,
20962 +                                        timeid=%EM_TIMEID,
20963 +                                        esmmethod=&EM_PROPERTY_FCMETHOD,
20964 +                                        criterion=&EM_PROPERTY_BESTCRIT,
20965 +                                        outdata= &_EXPORT_DATA
20966 +                                       );
20967 +    %end;
20968 +    %else %do;
20970 +             data &_EXPORT_DATA;
20971 +                  set &EM_USER_OUTDATA;
20972 +             run;
20974 +        * number of outliers;
20975 +        /* this block is added 09022011 */
20976 +        proc sql noprint;
20977 +            select count(*) into :_has_outlier from &EM_USER_OUTLIER where outlierindex eq 1;
20978 +        quit;
20980 +        %if &EM_PROPERTY_SMOOTHOUTLIER eq Y and &_has_outlier gt 0 %then %do;
20981 +            /* this block is moved from below 09022011 */
20982 +            %EM_TSESM_MakeSmoothedOutds(indata=&_EXPORT_DATA,
20983 +                                        inoutlierds=&EM_USER_OUTLIER,
20984 +                                        target=%EM_TARGET,
20985 +                                        timeid=%EM_TIMEID,
20986 +                                        replace=&EM_PROPERTY_OUTLIERREPLACE,
20987 +                                        outdata=&_EXPORT_DATA
20988 +                                        );
20990 +            * in this type of output DO NOT keep outlier flags;
20991 +            /* this block is added 09022011 */
20992 +            %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
20993 +                data &_EXPORT_DATA;
20994 +                    set &_EXPORT_DATA;
20995 +                    drop outlier:;
20996 +                run;
20997 +            %end;
20999 +        %end;
21000 +    %end;
21002 +   /*--------------- Modify and export columnsMeta ------------------------------------*/
21005 +      data _null_;
21006 +       length string $34;
21007 +       filename X "&_FILE_CDELTA";
21008 +       file X;
21011 +      %if (&_EXPORTDATA eq KLD)
21012 +       or (&_EXPORTDATA eq FORECAST)
21013 +       or (&_EXPORTDATA eq SIMILARITY)
21014 +      %then %do;
21016 +         %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
21017 +         %if &dsid > 0 %then %do;
21018 +            %let nvar = %sysfunc(attrn(&dsid, NVAR));
21019 +            %do i = 1 %to &nvar;  /* not 1= _NAMEID_   2=_TSID_ */
21020 +                 %let varname = %sysfunc(varname(&dsid, &i));
21022 +                      %if ~(( &varname eq _TSID_ ) or ( &varname eq _NAMEID_ ) ) %then  %do;
21023 +                          put "if UPCASE(STRIP(NAME)) eq UPCASE(STRIP('&varname')) then ROLE='CROSSID';";
21024 +                      %end;
21025 +             %end;
21027 +             %if (&_EXPORTDATA eq SIMILARITY)   %then %do;
21028 +                  put "if upcase(strip(ROLE)) eq 'TARGET' then ROLE = 'INPUT'; ";
21029 +             %end;
21031 +             %let dsid = %sysfunc(close(&dsid));
21032 +           %end;
21033 +           put "if UPCASE(STRIP(NAME)) eq '_TSID_' then ROLE='ID';";
21034 +           put "if UPCASE(STRIP(NAME)) eq '_VARNAME_' then ROLE='REJECTED';";
21035 +           put "if UPCASE(STRIP(NAME)) eq '_ROLE_' then ROLE='REJECTED';";
21036 +           put "if UPCASE(STRIP(NAME)) eq '_NAMEID_' then ROLE='ID';";
21038 +    %end;
21039 +    %else %do;
21040 +           put "if UPCASE(STRIP(NAME)) eq '_TSID_' then ROLE='ID';";
21041 +    %end;
21044 +    run;
21049 +    %ENDLINE:
21050 +%mend EM_TSESM_SCORE;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 7300 observations read from the data set EMWS1.TSESM_OUTFORCST.
NOTE: The data set EMWS1.TSESM_FORCSTPLOTDS has 7300 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 7300 observations read from the data set EMWS1.TSESM_FORCSTPLOTDS.
NOTE: The data set EMWS1.TSESM_FORCSTPLOTDS has 7300 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The file WORK._TMPTIMEDS (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file WORK._TMPTIMEDS2 (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 4 observations read from the data set EMWS1.TSESM_OUTSUM.
NOTE: The data set EMWS1.TSESM_OUTSUM has 4 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: The data set EMWS1.TSESM_TRAIN has 1825 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.04 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Variable string is uninitialized.
NOTE: The file X is:
      Filename=C:\Users\tan.joryi\Desktop\p\data_mining\03_explore_data\Gold_Price\Workspaces\EMWS1\TSESM\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=22 December 2019 20:01:51 o'clock,
      Create Time=11 December 2019 21:36:27 o'clock
 
NOTE: 1 record was written to the file X.
      The minimum record length was 50.
      The maximum record length was 50.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
21053
21054
21055  *------------------------------------------------------------*;
21056  * End SCORE: TSESM;
21057  *------------------------------------------------------------*;
 
21059  *------------------------------------------------------------*;
21060  * TSESM: Computing metadata for TRAIN data;
21061  *------------------------------------------------------------*;
 
*------------------------------------------------------------*
* Report Log
Date:                22 December 2019
Time:                20:01:53 o'clock
*------------------------------------------------------------*
21431  %let EMEXCEPTIONSTRING=;
21432  *------------------------------------------------------------*;
21433  * REPORT: TSESM;
21434  *------------------------------------------------------------*;
21435  %let EM_ACTION = REPORT;
21436  %let syscc = 0;
21437
21438  %macro EM_TSESM_MAIN;
21439
21440     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
21441     %include temp;
21442     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
21443     %include temp;
21444     filename temp;
21445
21446     %if %upcase(&EM_ACTION) = CREATE %then %do;
21447         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
21448         %include temp;
21449         filename temp;
21450         %EM_TSESM_CREATE;
21451     %end;
21452     %else
21453     %if %upcase(&EM_ACTION) = TRAIN %then %do;
21454          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
21455             %include temp;
21456             filename temp;
21457          %EM_TSESM_TRAIN;
21458     %end;
21459     %else
21460     %if %upcase(&EM_ACTION) = SCORE %then %do;
21461             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
21462             %include temp;
21463             filename temp;
21464           %EM_TSESM_SCORE;
21465     %end;
21466     %else
21467     %if %upcase(&EM_ACTION) = REPORT %then %do;
21468             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
21469             %include temp;
21470             filename temp;
21471            %EM_TSESM_REPORT;
21472     %end;
21473  %mend EM_TSESM_MAIN;
21474  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
21475 +/*----------------------------------------------------------------------------------+
21476 + |
21477 + |   Title :  Time Series data Mining Forcating Macros
21478 + |
21479 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
21480 + |
21481 + |
21482 + +-----------------------------------------------------------------------------------*/
21485 +%macro EM_TSESM_Forecast(indata=,
21486 +                method=,
21487 +                timeinterval=,
21488 +                timeid= ,
21489 +                target= ,
21490 +                tsidvar=,
21491 +                lead=,
21492 +                back=,
21493 +                startsum=,
21494 +                accumulate=,
21495 +                seasonality=,
21496 +                alpha=,
21497 +                extendedvalue=,
21498 +                outest = ,
21499 +                outdata = ,
21500 +                outfor = ,
21501 +                outstat = ,
21502 +                outsum=
21503 +   );
21506 +   %if &tsidvar eq _SEGMENT_ %then %do;
21507 +       proc sort data=&indata out=_tmpdata;
21508 +            by  &tsidvar %EM_CROSSID &timeid ;
21509 +       run;
21510 +       proc timeseries  data =_tmpdata out=_tmpdata;
21511 +            by  &tsidvar %EM_CROSSID;
21512 +            id &timeid interval=&timeinterval accumulate=&accumulate;
21513 +            var &target / ;
21514 +       run;
21515 +       proc esm data =_tmpdata
21516 +   %end;
21517 +   %else %do;
21518 +       proc sort data= &indata out=_tmpdata;
21519 +            by  &tsidvar %EM_CROSSID &timeid ;
21520 +       run;
21521 +       proc esm data = _tmpdata
21522 +   %end;
21523 +            lead=&lead  back=&back startsum=&startsum
21525 +   %if &seasonality ne DEFAULT %then %do;
21526 +            seasonality = &seasonality
21527 +   %end;
21530 +            out=&outdata
21531 +            outest=&outest
21532 +            outfor =&outfor
21533 +            outstat=&outstat
21534 +            outsum= &outsum
21535 +       ;
21536 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
21538 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21539 +            %if &target ne %then %do;
21540 +            forecast &target   /  model = none alpha=&alpha;
21541 +            %end;
21542 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21543 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
21544 +            %end;
21545 +        %end;
21546 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
21547 +            %if &target ne %then %do;
21548 +            forecast &target /  model =&method alpha=&alpha;
21549 +            %end;
21550 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21551 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
21552 +            %end;
21553 +        %end;
21554 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
21555 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
21556 +        %end;
21558 +   %if &tsidvar ne %then %do;
21559 +        by &tsidvar %EM_CROSSID ;
21560 +   %end;
21561 +   run;
21562 +%mend EM_TSESM_Forecast;
21565 +%macro EM_TSESM_CreateOutFor(indata=,
21566 +                            target=,
21567 +                            timeid=,
21568 +                            tsidVar=,
21569 +                            percent=,
21570 +                            outdata=);
21572 +  %let lowerBound = L&percent;
21573 +  %let upperBound = U&percent;
21575 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
21576 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
21577 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
21578 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
21579 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
21580 +       ds_std(rename=(&target=STD) drop=_TYPE_);
21581 +     set &indata;
21582 +       if _TYPE_="FORECAST" then output ds_fore;
21583 +       if _TYPE_="RESIDUAL" then output ds_resid;
21584 +       if _TYPE_="ACTUAL" then output ds_act;
21585 +       if _TYPE_="&lowerBound" then output ds_lower;
21586 +       if _TYPE_="&upperBound" then output ds_upper;
21587 +       if _TYPE_="STD" then output ds_std;
21588 +  run;
21590 +  data &outdata;
21591 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
21592 +       by &tsidVar &timeid;
21593 +       label  FORECAST = "Forecast";
21594 +       label  ACTUAL = "Actual";
21595 +       label  RESIDUAL = "Residual";
21596 +       label  LBOUND = "Lower Bound";
21597 +       label  UBOUND = "Upper Bound";
21598 +       label   STD = "Standard Deviation";
21599 +  run;
21600 +%mend EM_TSESM_CreateOutFor;
21603 +%macro EM_TSESM_CreateOutExpand(indata=,
21604 +                       target=,
21605 +                       timeid=,
21606 +                       tsidVar=,
21607 +                       percent=,
21608 +                       outlower=,
21609 +                       outupper=,
21610 +                       outdata=);
21612 +  %let lowerBound = L&percent;
21613 +  %let upperBound = U&percent;
21615 +  /*proc print data=&indata(obs=200);
21616 +  run;
21617 +  */
21619 +  data ds_fore(drop=&target)
21620 +       ds_lower(drop=&target)
21621 +       ds_upper(drop=&target)
21622 +       ds_act;
21623 +     set &indata;
21624 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
21625 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
21626 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
21627 +       if _TYPE_="ACTUAL" then output ds_act;
21628 +  run;
21630 +  /*
21631 +  proc print data = ds_fore;
21632 +  proc print data=ds_act;
21633 +  run;
21634 +  */
21635 +  data &outdata;
21636 +       merge ds_act ds_fore;
21637 +       by &tsidVar &timeid;
21638 +  run;
21640 +  data &outlower;
21641 +       merge ds_act ds_lower;
21642 +       by &tsidVar &timeid;
21643 +  run;
21645 +  data &outupper;
21646 +       merge ds_act ds_upper;
21647 +       by &tsidVar &timeid;
21648 +  run;
21649 +  /*
21650 +  proc print data=&outdata(obs=300);
21651 +  proc print data=&outlower(obs=300);
21652 +  proc print data=&outupper(obs=300);
21653 +  run;
21654 +  */
21655 +%mend EM_TSESM_CreateOutExpand;
21659 +%macro EM_TSESM_MakeOutClus(indata=,
21660 +                   target=,
21661 +                   timeid=,
21662 +                   tsidVar=,
21663 +                   percent=,
21664 +                   outlower=,
21665 +                   outupper=,
21666 +                   outdata=);
21669 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
21671 +  data &outdata(rename=(_NAME_ =_NAMEID_));
21672 +       set &indata;
21673 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
21674 +  run;
21676 +  %let dsid=%sysfunc(open(&outdata));
21677 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
21678 +  %let dsid=%sysfunc(close(&dsid));
21680 +  %if &vn_name > 0 %then %do;
21681 +      data &outdata(drop=_NAMEID_);
21682 +           merge &EM_USER_TSIDMAP &outdata;
21683 +           by _TSID_;
21684 +      run;
21685 +  %end;
21686 +  %else %do;
21687 +      proc sort data= &outdata; by _NAMEID_;
21688 +      run;
21689 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
21690 +      run;
21691 +      data &outdata(drop=_NAMEID_);
21692 +           merge &EM_USER_TSIDMAP &outdata;
21693 +           by _NAMEID_;
21694 +      run;
21695 +  %end;
21697 +%mend EM_TSESM_MakeOutClus;
21700 +%macro EM_TSESM_CreateOutEst(indata=,
21701 +                    target=,
21702 +                    timeid=,
21703 +                    outdata=);
21705 +%mend EM_TSESM_CreateOutEst;
21708 +%macro EM_TSESM_Best_Forecast(indata=,
21709 +                method=,
21710 +                timeinterval=,
21711 +                timeid= ,
21712 +                target= ,
21713 +                tsidvar=,
21714 +                lead=,
21715 +                back=,
21716 +                startsum=,
21717 +                accumulate=,
21718 +                seasonality=,
21719 +                alpha=,
21720 +                criterion=,
21721 +                extendedvalue=,
21722 +                outest = ,
21723 +                outdata = ,
21724 +                outfor = ,
21725 +                outstat = ,
21726 +                outsum=
21727 +   );
21729 +   %let _indata = &indata;
21731 +   %if &tsidvar eq _SEGMENT_ %then %do;
21732 +       proc sort data=&indata out=_tmpdata;
21733 +            by  &tsidvar %EM_CROSSID &timeid ;
21734 +       run;
21735 +       proc timeseries  data =_tmpdata out=_tmpdata;
21736 +            by  &tsidvar %EM_CROSSID ;
21737 +            id &timeid interval=&timeinterval accumulate=&accumulate;
21738 +            var &target / ;
21739 +       run;
21740 +       %let _indata = _tmpdata;
21741 +   %end;
21743 +   %let n_model = 0;
21745 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
21747 +       %let n_model = %eval(&n_model+1);
21749 +       %let _ds_out =_out&n_model;
21750 +       %let _ds_outest =_outest&n_model;
21751 +       %let _ds_outfor =_outfor&n_model;
21752 +       %let _ds_outstat =_outstat&n_model;
21753 +       %let _ds_outsum=_outsum&n_model;
21755 +       %EM_TSESM_ESM(method=SIMPLE,
21756 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21757 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21758 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21759 +        );
21761 +   %end;
21762 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
21764 +       %let n_model = %eval(&n_model+1);
21766 +       %let _ds_out =_out&n_model;
21767 +       %let _ds_outest =_outest&n_model;
21768 +       %let _ds_outfor =_outfor&n_model;
21769 +       %let _ds_outstat =_outstat&n_model;
21770 +       %let _ds_outsum=_outsum&n_model;
21772 +       %EM_TSESM_ESM(method=DOUBLE,
21773 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21774 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21775 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21776 +       );
21777 +   %end;
21779 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
21781 +       %let n_model = %eval(&n_model+1);
21782 +       %let _ds_out =_out&n_model;
21783 +       %let _ds_outest =_outest&n_model;
21784 +       %let _ds_outfor =_outfor&n_model;
21785 +       %let _ds_outstat =_outstat&n_model;
21786 +       %let _ds_outsum=_outsum&n_model;
21788 +       %EM_TSESM_ESM(method=LINEAR,
21789 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21790 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21791 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21792 +        );
21793 +   %end;
21795 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
21797 +       %let n_model = %eval(&n_model+1);
21799 +       %let _ds_out =_out&n_model;
21800 +       %let _ds_outest =_outest&n_model;
21801 +       %let _ds_outfor =_outfor&n_model;
21802 +       %let _ds_outstat =_outstat&n_model;
21803 +       %let _ds_outsum=_outsum&n_model;
21805 +       %EM_TSESM_ESM(method=DAMPTREND,
21806 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21807 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21808 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21809 +            );
21810 +   %end;
21811 +   /*------- Seasonal model ------*/
21813 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
21815 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
21817 +       %let n_model = %eval(&n_model+1);
21819 +       %let _ds_out =_out&n_model;
21820 +       %let _ds_outest =_outest&n_model;
21821 +       %let _ds_outfor =_outfor&n_model;
21822 +       %let _ds_outstat =_outstat&n_model;
21823 +       %let _ds_outsum=_outsum&n_model;
21825 +       %EM_TSESM_ESM(method=WINTERS,
21826 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21827 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21828 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21829 +        );
21830 +   %end;
21832 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
21834 +       %let n_model = %eval(&n_model+1);
21836 +       %let _ds_out =_out&n_model;
21837 +       %let _ds_outest =_outest&n_model;
21838 +       %let _ds_outfor =_outfor&n_model;
21839 +       %let _ds_outstat =_outstat&n_model;
21840 +       %let _ds_outsum=_outsum&n_model;
21842 +       %EM_TSESM_ESM(method=ADDSEASONAL,
21843 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21844 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21845 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21846 +       );
21847 +   %end;
21849 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
21851 +       %let n_model = %eval(&n_model+1);
21853 +       %let _ds_out =_out&n_model;
21854 +       %let _ds_outest =_outest&n_model;
21855 +       %let _ds_outfor =_outfor&n_model;
21856 +       %let _ds_outstat =_outstat&n_model;
21857 +       %let _ds_outsum=_outsum&n_model;
21859 +       %EM_TSESM_ESM(method=MULTSEASONAL,
21860 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21861 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21862 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21863 +       );
21864 +   %end;
21866 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
21868 +       %let n_model = %eval(&n_model+1);
21870 +       %let _ds_out =_out&n_model;
21871 +       %let _ds_outest =_outest&n_model;
21872 +       %let _ds_outfor =_outfor&n_model;
21873 +       %let _ds_outstat =_outstat&n_model;
21874 +       %let _ds_outsum=_outsum&n_model;
21876 +       %EM_TSESM_ESM(method=ADDWINTERS,
21877 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21878 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21879 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21880 +            );
21881 +   %end;
21884 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
21885 +   /*-------- end of seasonal model  ------------------------------------------------------*/
21887 +   %if &n_model eq 0 %then %do;
21889 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
21890 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
21891 +   %end;
21892 +   %else %do;
21893 +         %EM_TSESM_BestModelSel(crit=&criterion,
21894 +                               n_mdl=&n_model,
21895 +                               tsidvar=&tsidvar,
21896 +                               timeid=&timeid,
21897 +                               out=&outdata,
21898 +                               outest=&outest,
21899 +                               outfor =&outfor,
21900 +                               outstat=&outstat,
21901 +                               outsum=&outsum
21902 +                  );
21903 +   %end;
21905 +%mend EM_TSESM_Best_Forecast;
21908 +%macro EM_TSESM_ESM(method= ,
21909 +           timeinterval=,
21910 +           timeid= ,
21911 +           target= ,
21912 +           tsidvar=,
21913 +           lead=,
21914 +           back=,
21915 +           startsum=,
21916 +           accumulate=,
21917 +           seasonality=,
21918 +           alpha=,
21919 +           out= ,
21920 +           outest= ,
21921 +           outfor= ,
21922 +           outstat= ,
21923 +           outsum=
21924 +           );
21926 +       proc sort data= &_indata out=_tmpdata;
21927 +            by  &tsidvar %EM_CROSSID &timeid ;
21928 +       run;
21929 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
21931 +       %if &seasonality ne DEFAULT %then %do;
21932 +                     seasonality = &seasonality
21933 +       %end;
21934 +            out=&out
21935 +            outest=&outest
21936 +            outfor =&outfor
21937 +            outstat=&outstat
21938 +            outsum= &outsum
21939 +            ;
21940 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
21942 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21943 +            %if &target ne %then %do;
21944 +            forecast &target   /  model = none alpha=&alpha;
21945 +            %end;
21946 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21947 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
21948 +            %end;
21949 +       %end;
21950 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
21951 +            %if &target ne %then %do;
21952 +            forecast &target /  model =&method alpha=&alpha;
21953 +            %end;
21954 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21955 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
21956 +            %end;
21957 +       %end;
21958 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
21959 +            %if &target ne %then %do;
21960 +            forecast &target   /  model = &method alpha=&alpha;
21961 +            %end;
21962 +            /*
21963 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21964 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
21965 +            %end;
21966 +            */
21967 +       %end;
21969 +       %if &tsidvar ne %then %do;
21970 +        by &tsidvar %EM_CROSSID;
21971 +       %end;
21972 +       run;
21974 +%mend EM_TSESM_ESM;
21978 +%macro EM_TSESM_BestModelSel(crit=,
21979 +                    n_mdl=,
21980 +                    tsidvar=_TSID_,
21981 +                    timeid=MNTH_YR,
21982 +                    out=&_outdata,
21983 +                    outest=&_outest,
21984 +                    outfor =&_outfor,
21985 +                    outstat=&_outstat,
21986 +                    outsum=&_outsum
21987 +    );
21989 +   %let statbls=select *, 1 as mdlID from _outstat1;
21990 +   %let estbls=select *,  1 as mdlID from _outest1;
21991 +   %let fortbls=select *, 1 as mdlID from _outfor1;
21992 +   %let outbls=select *,  1 as mdlID from _out1;
21993 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
21994 +   %do i=2 %to &n_mdl;
21995 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
21996 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
21997 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
21998 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
21999 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
22000 +   %end;
22002 +   %let dsid=%sysfunc(open(_out1));
22003 +   %let vn_tsid = 0;
22005 +   %if &dsid > 0 %then %do;
22006 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22007 +         %let dsid = %sysfunc(close(&dsid));
22008 +   %end;
22010 +   %if &vn_tsid <= 0  %then %do;
22011 +       %let tsidvar=_NAME_;
22012 +   %end;
22014 +  /*
22015 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
22016 +     %let tsidvar=_NAME_;
22017 +   %end;
22018 +  */
22020 +   proc sql;
22021 +     create table tsstat as &statbls;
22022 +     create table tsest  as &estbls;
22023 +     create table tsfor  as &fortbls;
22024 +     create table tsout  as &outbls;
22025 +     create table tssum  as &sumtbls;
22026 +   quit;
22028 +    proc sort data=tsstat out=bestmdl;
22029 +        by &tsidvar &crit mdlID;
22030 +    run;
22032 +    * when multiple BEST model found;
22033 +    * use the one with smallest model ID;
22034 +    data bestmdl;
22035 +        set bestmdl;
22036 +        by &tsIDvar;
22037 +        if first.&tsIDVar;
22038 +    run;
22040 +   proc sql;
22041 +      create table bestID as
22042 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
22043 +        from bestmdl,tsest
22044 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
22046 +      create table &outfor
22047 +        as select tsfor.*, _model_, &crit from tsfor, bestID
22048 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22050 +        create table &outstat
22051 +        as select tsstat.*, _model_ from tsstat, bestID
22052 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
22054 +        create table &outest
22055 +        as select tsest.*, &crit from bestmdl, tsest
22056 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
22058 +      create table &outsum
22059 +        as select tssum.*, _model_, &crit from tssum, bestID
22060 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
22062 +      /*
22063 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
22064 +        create table &out
22065 +          as select tsout.*, _model_, &crit from tsout, bestID
22066 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22067 +      %end;
22068 +      */
22070 +      %if &tsidvar eq _TSID_ %then %do;
22072 +         create table &out
22073 +          as select tsout.*, _model_, &crit from tsout, bestID
22074 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22076 +      %end;
22077 + run;
22078 +quit;
22080 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
22082 + %if &tsidvar = _NAME_ %then %do;
22083 +      data
22084 +            %let i=1;
22085 +            %do i=1 %to &n_mdl;
22086 +               %let _tmpdsname = _tmpds&i;
22087 +                    &_tmpdsname
22088 +            %end;
22089 +        ;
22090 +         set work.Bestmdl;
22091 +            %let i=1;
22092 +            %do i=1 %to &n_mdl;
22093 +               %let _tmpdsname = _tmpds&i;
22094 +                  if mdlID = &i then output &_tmpdsname;
22095 +            %end;
22096 +      run;
22098 +      data &out;
22099 +           set _out1;
22100 +           keep &timeid %EM_TARGET;
22101 +      run;
22102 +      %let i=1;
22103 +      %do i=1 %to &n_mdl;
22104 +          %let _tmpdsname = _tmpds&i;
22105 +          %let _outdsname = _out&i;
22107 +          data &out;
22108 +               set &out;
22109 +               set &_outdsname(keep=
22110 +               %let dsid=%sysfunc(open(&_tmpdsname));
22111 +               %if &dsid > 0 %then %do;
22112 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
22113 +                  %do %while(^%sysfunc(fetch(&dsid)));
22114 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
22115 +                          &_name
22116 +                  %end;
22117 +                  %let dsid = %sysfunc(close(&dsid));
22118 +               %end;
22119 +               );
22120 +           run;
22121 +       %end;
22123 +%end;
22125 +data &out;
22126 +     set  &out;
22127 +      drop mdlID _MODEL_ &crit;
22128 +data &outest;
22129 +      set  &outest;
22130 +      drop mdlID &crit;
22131 +data &outfor;
22132 +     set &outfor;
22133 +     drop mdlID &crit;
22134 +data &outstat;
22135 +     set &outstat;
22136 +     drop mdlID;
22137 +data &outsum;
22138 +     set &outsum;
22139 +     drop mdlID &crit;
22140 +run;
22142 +%mend EM_TSESM_BestModelSel;
22146 +%macro EM_TSESM_MakeOutlierIndex(indata=,
22147 +                        target=,
22148 +                        timeid=,
22149 +                        outoutlier=,
22150 +                        outlierds=,
22151 +                        outdata=);
22152 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
22153 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
22154 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
22155 +data &outdata;
22156 +     set &indata;
22157 +     length OutlierIndex 8.;
22158 +     length Outlier  $40;
22159 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
22160 +     label  Outlier = "&label_Outlier";
22161 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
22162 +       else  do; OutlierIndex=0; outlier =" "; end; */
22163 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
22164 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
22165 +run;
22167 +data  &outoutlier;
22168 +      set  &outdata;
22169 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
22170 +      if ACTUAL = . then delete;
22171 +run;
22173 +data &outlierds;
22174 +     set &outoutlier;
22175 +     if OUTLIERINDEX = 0 then delete;
22176 +     Drop OUTLIERINDEX;
22177 +run;
22179 +%mend  EM_TSESM_MakeOutlierIndex;
22182 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
22183 +                         inoutlierds=,
22184 +                         target=,
22185 +                         timeid=,
22186 +                         tsidvar=_TSID_,
22187 +                         replace=,
22188 +                         outdata=);
22191 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22194 +%let dsid=%sysfunc(open(&indata));
22195 +%let vn_tsid = 0;
22196 +%if &dsid > 0 %then %do;
22197 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22198 +         %let dsid = %sysfunc(close(&dsid));
22199 +%end;
22201 +%if &vn_tsid <= 0  %then %do;
22202 +    %let tsidvar=_NAME_;
22203 +%end;
22205 +%if &tsidvar = _TSID_ %then %do;
22206 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
22207 + /*    data &outdata;
22208 +          merge &indata &inoutlierds;
22209 +          by _TSID_ &timeid;
22210 +          if OutlierIndex > 0 then
22211 +          %if &replace eq PREDICT %then %do;
22212 +             &target = PREDICT;
22213 +          %end;
22214 +          %else %do;
22215 +             &target = .;
22216 +          %end;
22217 +           Drop Predict _NAME_ OutlierIndex;
22218 +     run;     */
22219 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
22220 +     %if &dsid > 0 %then %do;
22221 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
22222 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22223 +         %let i = 1;
22224 +              %do %while(^%sysfunc(fetch(&dsid)));
22225 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
22226 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
22227 +                  %if &i eq 1 %then %do;
22228 +                      data _tmpoutlier;
22229 +                           set &inoutlierds;
22230 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
22231 +                      run;
22232 +                      data &outdata;
22233 +                           merge &indata _tmpoutlier;
22234 +                           by _TSID_ &timeid ;
22235 +                           if OutlierIndex  > 0 then
22236 +                              %if &replace eq PREDICT %then %do;
22237 +                                &_varname = PREDICT;
22238 +                              %end;
22239 +                              %else %do;
22240 +                                &_varname = .;
22241 +                              %end;
22242 +                            Drop Predict _NAME_  OutlierIndex Outlier;
22243 +                      run;
22244 +                   %end;
22245 +                   %else %do;
22246 +                      data _tmpoutlier;
22247 +                           set &inoutlierds;
22248 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
22249 +                      run;
22250 +                      data &outdata;
22251 +                           merge &outdata _tmpoutlier;
22252 +                           by _TSID_ &timeid ;
22253 +                           if OutlierIndex  > 0 then
22254 +                              %if &replace eq PREDICT %then %do;
22255 +                                &_varname = PREDICT;
22256 +                              %end;
22257 +                              %else %do;
22258 +                                &_varname = .;
22259 +                              %end;
22260 +                           Drop Predict _NAME_  OutlierIndex Outlier;
22261 +                      run;
22262 +                   %end;
22263 +                   %let i = %eval(&i+1);
22265 +              %end;
22266 +           %let dsid = %sysfunc(close(&dsid));
22267 +      %end;
22268 +%end;
22269 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
22271 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
22272 +     %if &dsid > 0 %then %do;
22273 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
22274 +         %let i = 1;
22275 +              %do %while(^%sysfunc(fetch(&dsid)));
22276 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
22277 +                  %if &i eq 1 %then %do;
22278 +                      data _tmpoutlier;
22279 +                           set &inoutlierds;
22280 +                           if _NAME_ ="&_varname"  then output;
22281 +                      run;
22282 +                      data &outdata;
22283 +                           merge &indata _tmpoutlier;
22284 +                           by &timeid;
22285 +                           if OutlierIndex  > 0 then
22286 +                              %if &replace eq PREDICT %then %do;
22287 +                                &_varname = PREDICT;
22288 +                              %end;
22289 +                              %else %do;
22290 +                                &_varname = .;
22291 +                              %end;
22292 +                            Drop Predict _NAME_ OutlierIndex Outlier;
22293 +                      run;
22294 +                   %end;
22295 +                   %else %do;
22296 +                      data _tmpoutlier;
22297 +                           set &inoutlierds;
22298 +                           if _NAME_ ="&_varname"  then output;
22299 +                      run;
22300 +                      data &outdata;
22301 +                           merge &outdata _tmpoutlier;
22302 +                           by &timeid;
22303 +                           if OutlierIndex  > 0 then
22304 +                              %if &replace eq PREDICT %then %do;
22305 +                                &_varname = PREDICT;
22306 +                              %end;
22307 +                              %else %do;
22308 +                                &_varname = .;
22309 +                              %end;
22310 +                           Drop Predict _NAME_ OutlierIndex Outlier;
22311 +                      run;
22312 +                   %end;
22313 +                   %let i = %eval(&i+1);
22315 +              %end;
22316 +           %let dsid = %sysfunc(close(&dsid));
22317 +      %end;
22318 +      %else %do;
22319 +            /* this block is added 09022011*/
22320 +            /* works for wide table in which each time series has a column */
22322 +            proc transpose data=&indata out=_tmpdata1;
22323 +                by &timeID;
22324 +            run;
22326 +            proc sql;
22327 +                create table _tmpdata2 as
22328 +                    select a.*, b.outlierindex, b.outlier, b.predict
22329 +                        from _tmpdata1 as a left join &inoutlierds as b
22330 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
22331 +                        order by a.&timeID, a._name_
22332 +                    ;
22333 +            quit;
22335 +            data _tmpdata2;
22336 +                set _tmpdata2;
22337 +                if outlierindex eq 1 then
22338 +                    if &replace eq PREDICT then col1=predict; else col1=.;
22339 +            run;
22341 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
22342 +                by &timeID;
22343 +                ID _name_;
22344 +                var col1;
22345 +            proc sort data=&inoutlierds out=_tmpoutlier;
22346 +                by &timeID _name_;
22347 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
22348 +                by &timeID;
22349 +                ID _name_;
22350 +                var outlier;
22351 +            run;
22353 +            data &outdata;
22354 +                merge _tmpdata3 _tmpdata4;
22355 +                by &timeID;
22356 +            run;
22357 +      %end;
22358 +%end;
22359 +%mend EM_TSESM_MakeSmoothedOutds;
22361 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
22362 +                  insumdata=&EM_USER_OUTSUM,
22363 +                target=&_targetVar,
22364 +                timeid=&_timeidVar,
22365 +                futurepoint=1,
22366 +                outKLD=&EM_USER_OUTKLD
22367 +                );
22369 +%if &futurepoint > 0 %then %do;
22371 +proc sort data=&indata out=_tmptimeid;
22372 +     by &timeid;
22373 +run;
22375 +data _tmptimeid(keep=&timeid);
22376 +      set _tmptimeid; by &timeid;
22377 +      if first.&timeid then output;
22378 +run;
22380 +%let _targetTime =;
22381 +%let dsid=%sysfunc(open(work._tmptimeid));
22382 +%if &dsid > 0 %then %do;
22383 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
22384 +    %let i = 1;
22385 +    %do %while(^%sysfunc(fetch(&dsid)));
22386 +       %if &i eq &futurepoint %then %do;
22387 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
22388 +       %end;
22389 +       %let i = %eval(&i+1);
22390 +    %end;
22391 +    %let dsid = %sysfunc(close(&dsid));
22392 +%end;
22394 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
22395 +   set &indata;
22396 +   if &timeid eq &_targetTime then output;
22397 +run;
22399 +%end;  /* end of %if &futurepoint > 0 %then %do; */
22400 +%else %do;
22403 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
22404 +   set &insumdata;
22405 +run;
22408 +%end;
22410 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
22412 +/* Merge TSIDMAP  */
22414 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22415 +data &outKLD(rename=(_NAME_ =_NAMEID_));
22416 +       set &outKLD;
22417 +run;
22419 +%let dsid=%sysfunc(open(&outKLD));
22420 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
22421 +%let dsid=%sysfunc(close(&dsid));
22423 +%if &vn_name > 0 %then %do;
22424 +      data &outKLD(drop=_NAMEID_);
22425 +           merge &EM_USER_TSIDMAP &outKLD;
22426 +           by _TSID_;
22427 +      run;
22428 +%end;
22429 +%else %do;
22430 +      proc sort data= &outKLD; by _NAMEID_;
22431 +      run;
22432 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
22433 +      run;
22434 +      data &outKLD(drop=_NAMEID_);
22435 +           merge &EM_USER_TSIDMAP &outKLD;
22436 +           by _NAMEID_;
22437 +      run;
22438 +%end;
22440 +/* delete _tmptimeid  _tmpKLD */
22441 +%Mend  EM_TSESM_MakeOutKLD;
22444 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
22445 +                 target=&_targetVar,
22446 +                 timeid=&_timeidVar,
22447 +                 outdata=&EM_USER_OUTPRED
22448 +                 );
22450 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22451 +%let _EndTime = ;
22452 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22453 +%if &dsid > 0 %then %do;
22454 +    %let vn_end =%sysfunc(varnum(&dsid, END));
22455 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
22456 +    %do %while(^%sysfunc(fetch(&dsid)));
22457 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22458 +       /*--------------------------------------------------------
22459 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
22460 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
22461 +        ---------------------------------------------------------*/
22462 +    %end;
22463 +    %let dsid = %sysfunc(close(&dsid));
22464 +%end;
22466 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
22467 +     set &indata;
22468 +     if &timeid > &_EndTime then output;
22469 +run;
22470 +%Mend  EM_TSESM_MakeOutPred;
22473 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
22475 +%let std_x = ;
22476 +%let mu_y = ;
22478 +%let dsid=%sysfunc(open(&indata));
22479 +%if &dsid > 0 %then %do;
22480 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
22481 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
22482 +    %let i=1;
22483 +    %do %while(^%sysfunc(fetch(&dsid)));
22484 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
22485 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
22486 +        %let _tsid = _TSID&i.;
22487 +        /* create new data set */
22488 +            %if &i = 1 %then %do;
22489 +            data _tmpindata;
22490 +                set &indata;
22491 +                  mu_x = &_pred;
22492 +                  std_x = &_std;
22493 +                  rename predict = mu_y;
22494 +                  rename std = std_y;
22495 +            run;
22496 +        data _tmpout;
22497 +                 set _tmpindata;
22498 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
22499 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
22500 +             &_tsid= (KLD1+KLD2)/2;
22501 +             if &_tsid < 0 then &_tsid = 0;
22502 +                   drop KLD1 KLD2;
22503 +         run;
22504 +             %end;
22505 +         %else %do;
22506 +         data _tmpindata;
22507 +                  set _tmpout;
22508 +                  mu_x = &_pred;
22509 +                  std_x = &_std;
22511 +             run;
22512 +         data _tmpout;
22513 +                 set _tmpindata;
22514 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
22515 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
22516 +             &_tsid= (KLD1+KLD2)/2;
22517 +             if &_tsid < 0 then &_tsid = 0;
22518 +                   drop KLD1 KLD2;
22519 +         run;
22521 +         %end;
22522 +             %let i = %eval(&i+1);
22524 +    %end;
22525 +    %let dsid = %sysfunc(close(&dsid));
22526 +    data &outdata;
22527 +         set _tmpout;
22528 +         drop mu_x mu_y std_x std_y;
22529 +    run;
22530 +%end;
22531 +%mend EM_TSESM_KLD;
22534 +%macro EM_TSESM_MakeOutClusInput(indata=,
22535 +                   target=,
22536 +                   timeid=,
22537 +                   tsidVar=,
22538 +                   percent=,
22539 +                   outlower=,
22540 +                   outupper=,
22541 +                   esmmethod=,
22542 +                   criterion=,
22543 +                   outdata=);
22545 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22547 +  data &outdata(rename=(_NAME_ =_NAMEID_));
22548 +       set &indata;
22549 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
22550 +  %if &esmmethod eq BEST %then %do;
22551 +      mdlID _MODEL_ &criterion
22553 +  %end;
22554 +  ;
22555 +  run;
22557 +  %let dsid=%sysfunc(open(&outdata));
22558 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
22559 +  %let dsid=%sysfunc(close(&dsid));
22561 +  %if &vn_name > 0 %then %do;
22562 +      proc sort data= &outdata; by _TSID_;
22563 +      run;
22564 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
22565 +      run;
22567 +      data &outdata(drop=_NAMEID_);
22568 +           merge &EM_USER_TSIDMAP &outdata;
22569 +           by _TSID_;
22570 +      run;
22571 +  %end;
22572 +  %else %do;
22573 +      proc sort data= &outdata; by _NAMEID_;
22574 +      run;
22575 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
22576 +      run;
22577 +      data &outdata(drop=_NAMEID_);
22578 +           merge &EM_USER_TSIDMAP &outdata;
22579 +           by _NAMEID_;
22580 +      run;
22581 +  %end;
22583 +%mend EM_TSESM_MakeOutClusInput;
22585 +%macro EM_TSESM_MakeOutSimInput(indata=,
22586 +                   inoutfor=,
22587 +                   target=,
22588 +                   timeid=,
22589 +                   tsidVar=,
22590 +                   esmmethod=,
22591 +                   criterion=,
22592 +                   outdata=);
22595 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22596 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22598 +   %let _EndTime = ;
22599 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
22600 +   %if &dsid > 0 %then %do;
22601 +   %let vn_end =%sysfunc(varnum(&dsid, END));
22602 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
22603 +   %do %while(^%sysfunc(fetch(&dsid)));
22604 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22605 +   %end;
22606 +   %let dsid = %sysfunc(close(&dsid));
22607 +   %end;
22609 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
22610 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
22612 +   data _out1;
22613 +       set &indata;
22614 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
22615 +           %tsesm_crossid
22616 +   %if &esmmethod eq BEST %then %do;
22617 +      mdlID _MODEL_ &criterion
22618 +   %end;
22619 +   ;
22620 +   run;
22622 +    %let dsid=%sysfunc(open(work._out1));
22623 +    %if &dsid > 0 %then %do;
22624 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22625 +      %let dsid = %sysfunc(close(&dsid));
22626 +    %end;
22628 +    /*
22629 +    proc print data=_out1(obs=10);
22630 +    run;
22631 +    */
22632 +    %let _existtsid = Y;
22633 +    %if (&vn_tsid = 0)  %then %do;
22634 +    %let _existtsid = N;
22635 +    %goto NO_TSID_SIMINPUT;
22636 +    %end;
22638 +    data _out1;
22639 +        set _out1;
22640 +        where _name_ = "&target";
22641 +    run;
22642 +    %let target2 = &target._;
22643 +    proc transpose data=_out1 out=_out2 prefix=&target2;
22644 +            id _TSID_  ;
22645 +    run;
22646 +    /*
22647 +    proc print data=_out2(obs=11);
22648 +    run;
22649 +    */
22650 +    data _out2;
22651 +       length _index 8.;
22652 +       set _out2;
22653 +       _index=_N_;
22654 +       drop _NAME_ _LABEL_;
22655 +    run;
22658 +   data _out3;
22659 +       length _index 8.;
22660 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
22661 +         _index =_N_;
22662 +        keep &timeid _index;
22664 +   run;
22665 +   /*
22666 +   proc print data=_out2(obs=12);
22667 +   proc print data =_out3(obs=13);
22668 +   run;
22669 +   */
22670 +   data &outdata(drop=_index);
22671 +        merge _out3 _out2;by _index;
22672 +        run;
22675 +  proc transpose data=&outdata out=_tout;
22676 +     id &timeid;
22677 +   run;
22678 +   data _tout;
22679 +        length _TSID_ 8.;
22680 +        set _tout;
22681 +        rename _NAME_= _NAMEID_;
22682 +        _TSID_ = _N_;
22683 +        label _NAME_ = "NAMEID";
22684 +        keep _NAME_ _TSID_;
22686 +   run;
22688 +   data &EM_USER_TSIDMAP;
22689 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
22690 +   run;
22691 +   /*
22692 +   proc print data=_tout(obs=14);
22693 +   run;
22694 +   */
22695 +   proc datasets lib=work nolist;
22696 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
22697 +   run;
22700 +   %NO_TSID_SIMINPUT:
22701 +   %if  &_existtsid eq N %then %do;
22702 +   data &outdata;
22703 +        set &inoutfor(where=(&timeid > &_EndTime));
22704 +   run;
22705 +   %end;
22708 +%mend EM_TSESM_MakeOutSimInput;
22711 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
22712 +%do i=1 %to &nwherevalue;
22713 +     %if &i = 1 %then %do;
22714 +        data &outdata(drop = &wherevar);
22715 +             set &indata;
22716 +               if &wherevar= &i;
22717 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
22718 +               %else %let newname = &wherevar_&i;
22719 +                rename  &targetvar= &newname;
22720 +                   label &targetvar ="&targetvar._&i";
22721 +           run;
22722 +       %end;
22723 +       %else %do;
22724 +        data _tmp_out(drop = &wherevar);
22725 +             set &indata;
22726 +               if &wherevar= &i;
22727 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
22728 +               %else %let newname = &wherevar_&i;
22729 +                rename  &targetvar= &newname;
22730 +                   label &targetvar ="&targetvar._&i";
22731 +           run;
22732 +             data &outdata;
22733 +                  merge &outdata  _tmp_out; by &timeid;
22734 +         run;
22735 +       %end;
22736 +%end;
22738 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
22740 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
22742 +/*
22743 +       MACRO: TS Utility macros
22745 +       PURPOSE: TS Utility macros
22746 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
22748 +       HISTORY:
22749 +       NOTE:
22751 +*/
22753 +/*
22754 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
22755 +                          timeid=, timeformat=, timeinformat=);
22756 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
22758 +    %do;
22759 +    %let m_data      = &data;
22760 +    %let m_decdata   = &decdata;
22761 +    %let m_decmeta   = &decmeta;
22762 +    %let m_cmeta     = &cmeta;
22763 +    %let m_outfile   = &outfile;
22764 +    %let m_crossid   = &crossid;
22765 +    %let m_timeid    = &timeid;
22766 +    %let m_timeformat    = &timeformat;
22767 +    %let m_timeinformat    = &timeinformat;
22768 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
22769 +  %end;
22770 +%mend EM_TS_CreateTsMetaDs;
22771 +*/
22772 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
22773 +proc sql;
22774 +      create table _tmp_inds
22775 +      as select distinct &timeid from  &indata;
22776 +quit;
22777 +run;
22778 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
22779 +  id &timeid
22780 +%if &timeinterval ne %then %do;
22781 +    %if &timeformattype eq DATE %then %do;
22782 +        interval=&timeinterval
22783 +    %end;
22784 +    %else %if &timeformattype eq DATETIME  %then %do;
22785 +        %let dttimeinterval= DT&timeinterval;
22786 +         interval=&dttimeinterval
22787 +    %end;
22788 +%end;
22789 +;
22790 +run;
22792 +data &outds;
22793 +     set _tmp_tsmeta;
22794 +     format START &timeformat;
22795 +     format END &timeformat;
22796 +     length APPLY_START_END $8;
22797 +     APPLY_START_END ="No";
22798 +     FORMAT = "&timeformat";
22799 +     ROLE ="TIMEID";
22800 +     rename TIMEID = NAME;
22801 +     rename SEASONALITY= LengthOfCycle;
22802 +     rename INTERVAL = TIMEINTERVAL ;
22803 +     rename FORMAT = TIMEFORMAT;
22804 +     output;
22805 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
22806 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
22807 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
22808 +run;
22810 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
22811 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
22813 +%mend EM_TS_CreateTSMetaData;
22817 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
22819 +/* if updated = Y it will pass the TSMETA created by just the previous node */
22821 +%let _tsmetads = ;
22823 +%if &updated = Y %then %do;
22824 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
22825 +%if %sysfunc(exist(&_tsmetads)) %then %do;
22826 +%goto endline;
22827 +%end;
22828 +%end;
22830 +%if &eminfodata eq %then %do;
22831 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
22832 +    data &EM_DATA_EMINFO;
22833 +         set &EM_IMPORT_DATA_EMINFO;
22834 +    run;
22835 +%end;
22836 +%else %do;
22837 +    %let dsid=%sysfunc(open(&eminfodata));
22838 +    data &EM_DATA_EMINFO;
22839 +         set &eminfodata;
22840 +    run;
22841 +%end;
22842 +%if &dsid > 0 %then %do;
22843 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
22844 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
22845 +    %do %while(^ %sysfunc(fetch(&dsid)));
22846 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
22847 +         %if &_key eq TSMETA %then %do;
22848 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
22849 +         %end;
22850 +    %end;
22851 +    %let dsid = %sysfunc(close(&dsid));
22852 +%end; /* the end of %if &dsid > 0 %then %do; */
22854 +%endline:
22856 +%if &_tsmetads ne %then %do;
22857 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
22858 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22859 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
22860 +         data &EM_USER_TSMETA;
22861 +                   set &_tsmetads;
22862 +         run;
22863 +    %end;
22864 +%end;
22866 +*proc print data=&EM_DATA_EMINFO;
22867 +*proc print data=&EM_IMPORT_DATA_EMINFO;
22868 +*run;
22869 +%MEND EM_TS_GETTSMETA;
22872 +/*
22873 +%macro EM_GETTSMETAVARS(TimeInterval=);
22874 +%global &TimeInterval;
22875 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22876 +%if &dsid > 0 %then %do;
22877 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
22878 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
22879 +%do %while(^ %sysfunc(fetch(&dsid)));
22880 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22881 +     %if &_role eq TIMEID %then %do;
22882 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
22883 +     %end;
22884 +%end;
22885 +%let dsid = %sysfunc(close(&dsid));
22886 +%end;
22887 +%MEND EM_GETTSMETAVARS;
22888 +*/
22889 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
22890 +%global &TimeInterval;
22891 +%global &TimeId;
22892 +%global &EndTime;
22893 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22894 +proc print data=&EM_USER_TSMETA;
22895 +run;
22896 +%if &dsid > 0 %then %do;
22897 +%if &TimeInterval ne %then %do;
22898 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
22899 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22900 +    %do %while(^ %sysfunc(fetch(&dsid)));
22901 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22902 +        %if &_role eq TIMEID %then %do;
22903 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
22904 +        %end;
22905 +     %end;
22906 +%end;
22907 +%if &TimeId ne %then %do;
22908 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
22909 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22910 +    %do %while(^ %sysfunc(fetch(&dsid)));
22911 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22912 +        %if &_role eq TIMEID %then %do;
22913 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
22914 +        %end;
22915 +    %end;
22916 +%end;
22918 +%if &EndTime ne %then %do;
22919 +    %let vn_end =%sysfunc(varnum(&dsid, END));
22920 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22921 +    %do %while(^ %sysfunc(fetch(&dsid)));
22922 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22923 +        %if &_role eq TIMEID %then %do;
22924 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22925 +        %end;
22926 +     %end;
22927 +%end;
22928 +%let dsid = %sysfunc(close(&dsid));
22929 +%end;
22930 +%MEND EM_TS_GETTSMETAVARS;
22934 +/*------------------------------------------------------------------
22936 +      Macro EM_GETTSIDMAP
22938 +------------------------------------------------------------------+*/
22941 +%macro EM_TS_GETTSIDMAP(updated=);
22943 +%let _tsidmap = ;
22945 +%if &updated = Y %then %do;
22946 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
22947 +%if %sysfunc(exist(&_tsidmap)) %then %do;
22948 +%goto endline;
22949 +%end;
22950 +%end;
22952 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
22953 +%if &dsid > 0 %then %do;
22954 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
22955 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
22956 +%do %while(^ %sysfunc(fetch(&dsid)));
22957 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
22958 +     %if &_key eq TSIDMAP %then %do;
22959 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
22960 +     %end;
22961 +%end;
22963 +%let dsid = %sysfunc(close(&dsid));
22964 +%end;
22966 +%endline:
22968 +%if &_tsidmap ne %then %do;
22970 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
22971 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22973 +%if %sysfunc(exist(&_tsidmap)) %then %do;
22974 +         data &EM_USER_TSIDMAP;
22975 +               set &_tsidmap;
22976 +         run;
22977 +    %end;
22978 +%end;
22979 +%MEND EM_TS_GETTSIDMAP;
22981 +/*------------------------------------------------------------------*/
22986 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
22987 +%global &value;
22990 +%let dsid = %sysfunc(open(&data));
22991 +%if &dsid > 0 %then %do;
22992 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
22993 +    %if &vn_var < 1 %then %do;
22994 +        %let &value = 0;
22995 +        %let dsid = %sysfunc(close(&dsid));
22996 +        %goto endline;
22997 +    %end;
22998 +%let dsid = %sysfunc(close(&dsid));
22999 +%end;
23001 +%let _tmp=_tmpDS;
23002 +proc means data=&data &stat;
23003 +     var &var;
23004 +     output out=&_tmp;
23005 +run;
23007 +%let dsid = %sysfunc(open(&_tmp));
23008 +%if &dsid > 0 %then %do;
23009 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
23010 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
23011 +     %do %while(^%sysfunc(fetch(&dsid)));
23012 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
23013 +         %if &_stat eq &stat %then %do;
23014 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
23015 +          %end;
23016 +      %end;
23017 +%let dsid = %sysfunc(close(&dsid));
23018 +%end;
23019 +proc datasets lib=work nolist;
23020 + delete &_tmp;
23021 +run;
23022 +%endline:
23023 +%MEND EM_TS_GET_STAT;
23026 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
23027 +%global &format;
23028 +%global &informat;
23029 +%let dsid = %sysfunc(open(&data));
23030 +%if &dsid > 0 %then %do;
23031 +%let vn_var =%sysfunc(varnum(&dsid, &var));
23032 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
23033 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
23034 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
23035 +%end;
23036 +%let dsid = %sysfunc(close(&dsid));
23037 +%end;
23038 +%MEND EM_TS_GET_VAR_FORMAT;
23040 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
23041 +      %if &lib eq %then %let lib=work;
23042 +       proc datasets lib=&lib nolist;
23043 +              delete &dsname;
23044 +       run;
23045 +%Mend  EM_TS_DELETE_DATA;
23048 +%macro EM_TS_GetNObs(inds=, nobs=);
23049 +    %global &nobs;
23050 +    %let &nobs=0;
23051 +    data _null_;
23052 +        set &inds end=eof;
23053 +        if eof then call symput("&nobs", _N_);
23054 +    run;
23055 +    quit;
23057 +    /*
23058 +    %let dsid=%sysfunc(open(&outdata));
23059 +    %if dsid > 0 %then %do;
23060 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
23061 +        %let dsid = %sysfunc(close(&dsid));
23062 +     %end;
23063 +    */
23064 +%mend  EM_TS_GetNObs;
23067 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
23068 +%global &time1;
23069 +%global &time2;
23070 +%if &default = Y %then %do;
23071 +   data _null_;
23072 +        set &data end=eof;
23073 +        if _N_ = 1 then  call symput("&time1", DATE);
23074 +        if eof then call symput("&time2", DATE);
23075 +    run;%end;
23076 +%else %do;
23077 +    %let dsid = %sysfunc(open(&data));
23078 +    %if &dsid > 0 %then %do;
23079 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
23080 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
23081 +        %do %while(^%sysfunc(fetch(&dsid)));
23082 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
23083 +             %if &_index eq 1 %then %do;
23084 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
23085 +             %end;
23086 +             %if &_index eq 2 %then %do;
23087 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
23088 +             %end;
23089 +        %end;
23090 +    %let dsid = %sysfunc(close(&dsid));
23091 +    %end;
23092 +%end;
23094 +%MEND EM_TS_GET_TIME_VALUES;
23096 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
23097 +%global &exist;
23098 + %let &exist = N;
23099 +%let dsid = %sysfunc(open(&data));
23100 +%if &dsid > 0 %then %do;
23101 +%let vn_var =%sysfunc(varnum(&dsid, &var));
23102 +%if &vn_var > 0 %then %do;
23103 +    %let &exist = Y;
23104 +%end;
23105 +%let dsid = %sysfunc(close(&dsid));
23106 +%end;
23107 +%MEND EM_TS_GET_VAR_EXIST;
23110 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
23111 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
23112 +      set &intreedata;
23113 +        LENGTH NodeType $32;
23114 +      if _PARENT_ eq " " then delete;
23115 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
23116 +        else NodeType = "CLUSTER";
23117 +        LinkID = _N_;
23118 +run;
23119 +%Mend EM_TS_MakeConstellPlotData;
23124 +%macro EM_TS_CreateIDMap(
23125 +/*-------------------------------------------------------------------------*/
23126 +/*---   Written by Xiangxiang Meng                                         */
23127 +/*-------------------------------------------------------------------------*/
23128 +inDS          =,      /* imported data set in TS data mining               */
23129 +outIDMap      =,      /* output data set of TS ID map                      */
23130 +outDS         =,      /* output data set of TS and TS ID merged            */
23131 +variableSet   =,      /* EM variable set                                   */
23132 +TSIDbyCrossID =Y,
23133 +inEM          =Y
23134 +/*-------------------------------------------------------------------------*/
23135 +);
23137 +%global EM_TS_ERR;
23138 +%let EM_TS_ERR = 0;
23140 +%if &inEM eq Y %then %do;
23141 +    %let num_crossIDVar = &EM_NUM_CROSSID;
23142 +    proc sql noprint;
23143 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
23144 +    quit;
23145 +%end;
23146 +%else %do;
23147 +    proc sql noprint;
23148 +         select count(*) into :num_crossIDVar from &variableSet
23149 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23150 +         ;
23151 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
23152 +         ;
23153 +    quit;
23154 +    %let num_crossIDVar=&num_crossIDVar;
23155 +%end;
23157 +* see if _TSID_ exists;
23159 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
23160 +run;
23162 +proc sql noprint;
23163 +    select count(*) into :has_TSID
23164 +        from _emtscm_contents
23165 +        where upcase(strip(name)) eq '_TSID_'
23166 +    ;
23167 +quit;
23169 +/*-------------------------------------------------------------------------*/
23170 +* Creating TSID map..;
23171 +/*-------------------------------------------------------------------------*/
23173 +%if (&num_crossIDVar gt 0) %then %do;
23175 +    data _emtscm_tmpIDMap;
23176 +        set &variableSet;
23177 +        where  (upcase(strip(level)) eq 'INTERVAL')
23178 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
23179 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
23180 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
23181 +          );
23182 +        _emts_dummy=1;
23183 +        keep name label role _emts_dummy;
23184 +    run;
23186 +    proc sql noprint;
23187 +        * create a string of crossID variable like A,B,C,D..;
23188 +        select distinct name into :crossIDVar separated by ','
23189 +            from &variableSet
23190 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23191 +            order by name
23192 +        ;
23193 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
23194 +            from &variableSet
23195 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23196 +            order by name
23197 +        ;
23198 +        * create the TSID map data set;
23199 +        create table _emtscm_tmp1 as
23200 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
23201 +        ;
23202 +        * create a level list of cross ID variables and time series variables;
23203 +        create table &outIDMap as
23204 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
23205 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
23206 +            where a._emts_dummy eq b._emts_dummy
23207 +            order by a.name, &crossIDVar
23208 +        ;
23209 +    quit;
23211 +    %if &TSIDbyCrossID = Y %then %do;
23212 +        * create unique TSID only by Cross ID;
23213 +        data &outIDMap;
23214 +            length _TSID_ 8;
23215 +            set &outIDMap;
23216 +            by _NAMEID_;
23217 +            if first._NAMEID_
23218 +                then _TSID_=1;
23219 +                else _TSID_+1;
23220 +        run;
23221 +        %if "&outDS" ne "" %then %do;
23222 +            * merge TSID into &inDS;
23223 +            proc sql noprint;
23224 +                create table &outDS as
23225 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
23226 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
23227 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
23228 +                        where %do i = 1 %to &num_crossIDVar;
23229 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
23230 +                              %end;
23231 +                             b._TSID_ is not missing
23232 +                    order by b._TSID_, a.&timeIDVar
23233 +                ;
23234 +            quit;
23235 +        %end;
23236 +    %end;
23237 +    %else %do;
23238 +        * create unique TSID by Cross ID and _NAMEID_;
23239 +        data &outIDMap;
23240 +            length _TSID_ 8;
23241 +            set &outIDMap;
23242 +            _TSID_=_n_;
23243 +        run;
23244 +        %if "&outDS" ne "" %then %do;
23245 +            *no merge in this output;
23246 +            data &outDS;
23247 +                set &inDS;
23248 +            run;
23249 +        %end;
23250 +    %end;
23252 +    proc sort data=&outIDMap;
23253 +        by _NAMEID_ _TSID_;
23254 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
23255 +        format _TSID_ best12. _NAMEID2_ $40.;
23256 +        set &outIDMap;
23257 +        by _NAMEID_;
23258 +        if first._NAMEID_
23259 +            then _emts_ind=1;
23260 +            else _emts_ind+1;
23261 +        drop _emts_ind;
23262 +        rename _NAMEID_=_VARNAME_;
23263 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
23264 +        if _labelID_ eq ' '
23265 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
23266 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
23267 +    run;
23269 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
23271 +%end;
23272 +%else %do; /* if no crossid's the nameid needs to be created */
23274 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
23275 +        length _TSID_ 8;
23276 +        set &variableSet;
23277 +        where  (upcase(strip(level)) eq 'INTERVAL')
23278 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
23279 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
23280 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
23281 +          );
23282 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
23283 +        rename ROLE = _ROLE_;
23284 +        _NAMEID_=strip(name);
23285 +        _VARNAME_=strip(name);
23286 +        if label eq ' '
23287 +            then _LABELID_ = strip(name);
23288 +            else _LABELID_ = strip(label);
23289 +        _TSID_=_n_;
23290 +    run;
23292 +    %if "&outDS" ne "" %then %do;
23293 +        *no merge in this output;
23294 +        data &outDS;
23295 +            set &inDS;
23296 +        run;
23297 +    %end;
23298 +%end;
23300 +data &outIDMap;
23301 +    set &outIDMap;
23302 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
23303 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
23304 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
23305 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
23306 +run;
23308 +proc datasets lib=work nolist;
23309 +    delete _emtscm_:;
23310 +run; quit;
23312 +%mend EM_TS_createIDMap;
23314 +%macro EM_TS_CreateMetaData(
23315 +/*-------------------------------------------------------------------------*/
23316 +  inDS          =,      /* imported data set in TS data mining             */
23317 +  outDS         =,      /* output data set of TS metadata                  */
23318 +  variableSet   =,      /* EM variable set                                 */
23319 +  timeInterval  =,      /* time interval                                   */
23320 +  rc            =       /* return code                                     */
23321 +/*-------------------------------------------------------------------------*/
23322 +);
23324 +%if %eval(
23325 +      &EM_NUM_BINARY_INPUT   +
23326 +      &EM_NUM_ORDINAL_INPUT  +
23327 +      &EM_NUM_NOMINAL_INPUT  +
23328 +      &EM_NUM_BINARY_REJECTED   +
23329 +      &EM_NUM_ORDINAL_REJECTED  +
23330 +      &EM_NUM_NOMINAL_REJECTED  +
23331 +      &EM_NUM_ORDINAL_TARGET  +
23332 +      &EM_NUM_NOMINAL_TARGET +
23333 +      &EM_NUM_BINARY_TARGET
23334 +      ) > 0
23335 +%then %do;
23336 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
23337 +        %put &em_codebar;
23338 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
23339 +        %put &errormsg;
23340 +        %put &em_codebar;
23341 +        %goto ENDLINE;
23342 +%end;
23344 +%global EM_TS_ERR;
23345 +%let EM_TS_ERR = 0;
23347 +%if &timeInterval eq AUTO
23348 +    %then %let timeInterval  = ;
23349 +    %else %let timeInterval  = %upcase(&timeInterval);
23351 +/*-------------------------------------------------------------------------*/
23352 +* check time ID variable;
23353 +/*-------------------------------------------------------------------------*/
23355 +* number of variables in the Variableset with ROLE=TIMEID;
23356 +proc sql noprint;
23357 +    select count(*) into :num_timeID from &variableset
23358 +        where upcase(role) eq 'TIMEID';
23359 +quit;
23361 +/*-------------------------------------------------------------------------*/
23362 +* process only when there is one Time ID, otherwise exception message;
23363 +/*-------------------------------------------------------------------------*/
23365 +%if &num_timeID eq 0 %then %do;
23367 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
23368 +    %let EM_TS_ERR = 11;
23369 +    %put &em_codebar;
23370 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
23371 +    %put &errormsg;
23372 +    %put &em_codebar;
23373 +    %goto tscm_endline;
23375 +%end;
23376 +%else %if &num_timeID gt 1 %then %do;
23378 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
23379 +    %let EM_TS_ERR = 12;
23380 +    %put &em_codebar;
23381 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
23382 +    %put &errormsg;
23383 +    %put &em_codebar;
23384 +    %goto tscm_endline;
23386 +%end;
23387 +%else %do;
23388 +    *** proceed when there is one Time ID;
23390 +    data _null_;
23391 +        set &variableset(where=(upcase(role)='TIMEID'));
23392 +        call symput('timeIDFormat',     strip(format));
23393 +        call symput('timeID',           strip(upcase(name)      ));
23394 +        call symput('timeIDLevel',      strip(upcase(level))     );
23395 +        call symput('timeIDFormatType', strip(upcase(formattype)));
23396 +    run;
23398 +    *** exception message if the time ID is not an interval variable;
23399 +    %if &timeIDLevel ne INTERVAL %then %do;
23400 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
23401 +        %let EM_TS_ERR = 13;
23402 +        %put &em_codebar;
23403 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
23404 +        %put &errormsg;
23405 +        %put &em_codebar;
23406 +        %goto tscm_endline;
23407 +    %end;
23409 +    %if (&timeIDFormatType ne DATETIME) and
23410 +        (&timeIDFormatType ne DATE) and
23411 +        (&timeIDFormatType ne TIME) and
23412 +        (&timeIDFormatType ne USER)
23413 +    %then %do;
23414 +        *** sequential format-type of time ID;
23416 +        %let timeInterval = DAY;
23417 +        %let timeIDFormatType = SEQ;
23419 +        proc sql noprint;
23420 +            create table _emtscm_inds as
23421 +                 select distinct &timeID from &inDS(keep=&timeID)
23422 +                 where &timeID is not missing;
23423 +            select count(*) into :num_nonInteger from _emtscm_inds
23424 +                where &timeID ne int(&timeID);
23425 +        quit;
23427 +        %if &num_nonInteger gt 0 %then %do;
23428 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
23429 +            %let EM_TS_ERR = 14;
23430 +            %put &em_codebar;
23431 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
23432 +            %put &errormsg;
23433 +            %put &em_codebar;
23434 +            %goto tscm_endline;
23435 +        %end;
23436 +    %end;
23437 +    %else %do;
23438 +        *** date, datetime, time format-type of time ID;
23440 +        *** must have a format;
23441 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
23442 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
23443 +            %let EM_TS_ERR = 15;
23444 +            %put &em_codebar;
23445 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
23446 +            %put &errormsg;
23447 +            %put &em_codebar;
23448 +            %goto tscm_endline;
23449 +        %end;
23451 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
23452 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
23453 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
23454 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
23455 +                %let EM_TS_ERR = 16;
23456 +                %put &em_codebar;
23457 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
23458 +                %put &errormsg;
23459 +                %put &em_codebar;
23460 +                %goto tscm_endline;
23461 +            %end;
23462 +        %end;
23464 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
23465 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
23466 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
23467 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
23468 +                %let EM_TS_ERR = 17;
23469 +                %put &em_codebar;
23470 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
23471 +                %put &errormsg;
23472 +                %put &em_codebar;
23473 +                %goto tscm_endline;
23474 +            %end;
23475 +        %end;
23477 +        *** the AUTO function is currently turned off for TIME timeID variable;
23478 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
23479 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
23480 +            %let EM_TS_ERR = 18;
23481 +            %put &em_codebar;
23482 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
23483 +            %put &errormsg;
23484 +            %put &em_codebar;
23485 +            %goto tscm_endline;
23486 +        %end;
23488 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
23489 +            %then %let timeInterval =DT&timeInterval;
23491 +        proc sql noprint;
23492 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
23493 +                where &timeID is not missing;
23494 +        quit;
23495 +    %end;
23497 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
23498 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
23499 +    run;
23501 +    %let hasValidInterval = 0;
23502 +    %let hasLengthOne     = 0;
23504 +    proc sql noprint;
23505 +        create table _emtscm_label as
23506 +            select name,label
23507 +            from dictionary.columns
23508 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
23509 +        ;
23510 +        create table _emtscm_meta2 as
23511 +            select a.*, b.label
23512 +            from _emtscm_meta as a, _emtscm_label as b
23513 +            where upcase(a.timeID) eq upcase(b.name)
23514 +        ;
23515 +    quit;
23517 +    data &outDS;
23518 +        set _emtscm_meta2;
23519 +        format
23520 +            timeformat      $30.
23521 +            role            $10.
23522 +            start           &timeIDformat
23523 +            end             &timeIDformat
23524 +            apply_start_end $8.
23525 +        ;
23526 +        rename
23527 +            timeID      = name
23528 +            seasonality = lengthOfCycle
23529 +            interval    = timeinterval
23530 +        ;
23531 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
23533 +        role            = "TIMEID";
23534 +        apply_start_end = 'N';
23535 +        timeformat      = symget('timeIDformat');
23536 +        timeformattype  = symget('timeIDformatType');
23538 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
23539 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
23540 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
23541 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
23542 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
23543 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
23544 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
23545 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
23546 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
23547 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
23549 +        if timeformattype eq 'SEQ' then do;
23550 +            timeformat='BEST12.';
23551 +            seasonality=1;
23552 +        end;
23554 +        call symput('_tinterval',interval);
23556 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
23558 +        if upcase(timeformattype) eq 'DATE' and
23559 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
23560 +            then call symput('hasValidInterval',1);
23562 +        if upcase(timeformattype) eq 'DATETIME' and
23563 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
23564 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
23565 +            then call symput('hasValidInterval',1);
23567 +        if upcase(timeformattype) eq 'TIME' and
23568 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
23569 +            then call symput('hasValidInterval',1);
23571 +        if upcase(timeformattype) eq 'SEQ'
23572 +            then call symput('hasValidInterval',1);
23574 +        if upcase(timeformattype) eq 'USER'
23575 +            then call symput('hasValidInterval',1);
23577 +        if start eq end
23578 +            then call symput('hasLengthOne',1);
23579 +    run;
23581 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
23583 +    *** detect any missing time interval after running PROC TIMEID;
23584 +    %if &_tinterval eq %then %do;
23585 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
23586 +        %let EM_TS_ERR = 19;
23587 +        %put &em_codebar;
23588 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
23589 +        %put &errormsg;
23590 +        %put &em_codebar;
23591 +        %goto tscm_endline;
23592 +    %end;
23594 +    *** detect any missing time interval after running PROC TIMEID;
23595 +    %if &hasValidInterval eq 0 %then %do;
23596 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
23597 +        %let EM_TS_ERR = 20;
23598 +        %put &em_codebar;
23599 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
23600 +        %put &errormsg;
23601 +        %put &em_codebar;
23602 +        %goto tscm_endline;
23603 +    %end;
23605 +    %if &hasLengthOne eq 1 %then %do;
23606 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
23607 +        %let EM_TS_ERR = 21;
23608 +        %put &em_codebar;
23609 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
23610 +        %put &errormsg;
23611 +        %put &em_codebar;
23612 +        %goto tscm_endline;
23613 +    %end;
23615 +%end;
23617 +%tscm_endline:;
23619 +%mend EM_TS_CreateMetaData;
23622 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
23624 +data _null_;
23625 +    set &tsmeta;
23626 +    call symput('_timeidFormatType', timeformattype);
23627 +    call symput('_timeid', strip(name));
23628 +    call symput('_seqstartnum',strip(put(start,best12.)));
23629 +run;
23631 +proc contents data=&inDS noprint
23632 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
23633 +run; quit;
23635 +data _null_;
23636 +    set _emts_tmpp1;
23637 +    call symput('_timeIDlabel',label);
23638 +run;
23640 +%if &_timeidFormatType eq SEQ
23641 +%then %do;
23642 +    proc sql noprint;
23643 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
23644 +    quit;
23645 +    %let _dummystarttime=&_dummystarttime;
23647 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
23648 +        set &inDS;
23649 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
23650 +        drop &_timeid;
23651 +        label _tsdp_tmpID = "&_timeIDlabel";
23653 +    run;
23654 +%end;
23656 +%mend;
23658 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
23660 +data _null_;
23661 +    set &tsmeta;
23662 +    call symput('_timeidFormatType', timeformattype);
23663 +    call symput('_timeidFormat', timeformat);
23664 +    call symput('_timeid', strip(name));
23665 +    call symput('_timeinterval',strip(upcase(timeinterval)));
23666 +run;
23668 +/* manually change time ID format to a longer enough time format */
23669 +/* because proc timeid returns time5. for second time interval */
23670 +/* which is not long enough for transpose with time unit as seconds */
23671 +%if &_timeinterval eq SECOND
23672 +%then %do;
23673 +    %let _timeIDformat = %str(time8.);
23674 +%end;
23676 +proc contents data=&inDS noprint
23677 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
23678 +run; quit;
23680 +data _null_;
23681 +    set _emts_tmpp1;
23682 +    call symput('_timeIDlabel',label);
23683 +run;
23685 +%if &_timeidFormatType eq TIME
23686 +%then %do;
23687 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
23688 +        set &inDS;
23689 +        _tsdp_tmpID = timepart(&_timeID);
23690 +        format _tsdp_tmpID &_timeidFormat;
23691 +        label  _tsdp_tmpID = "&_timeIDlabel";
23692 +        drop &_timeid;
23693 +    run;
23694 +%end;
23696 +%mend;
23698 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
23700 + proc sql noprint;
23701 +     create table _tmptimetable as
23702 +         select distinct &timeidvar as DATE from &inDS
23703 +         where &timeIDVar is not missing
23704 +         order by &timeIDVar;
23705 + quit;
23707 +%if &compare eq Y %then %do;
23708 +    * compare with the existing time table;
23709 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
23710 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
23711 +    run;
23713 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
23715 +    %if &_diffobs > 0 %then %do; /* create it again */
23716 +        data &outDS(keep=DATE _INDEX_);
23717 +            set _tmptimetable end = _eof_;
23718 +            if _N_ = 1
23719 +                then _INDEX_ = 1;
23720 +                else _INDEX_ = 0;
23721 +            if _eof_ then _INDEX_= 2;
23722 +        run;
23723 +    %end;
23725 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
23726 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
23727 +%end;
23728 +%else %do;
23729 +    * create a new time table directly;
23730 +    data &outDS(keep=DATE _INDEX_);
23731 +        set _tmptimetable end = _eof_;
23732 +        if _N_ = 1
23733 +            then _INDEX_ = 1;
23734 +            else _INDEX_ = 0;
23735 +        if _eof_ then _INDEX_= 2;
23736 +    run;
23738 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
23739 +%end;
23741 +* assign a defult format BEST12. for sequential time ID;
23743 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
23745 +%let _nodatefmt=N;
23747 +data _null_;
23748 +    set _tmpcontents;
23749 +    where upcase(name) eq 'DATE';
23750 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
23751 +run;
23753 +%if "&_nodatefmt" eq "Y" %then %do;
23754 +    data &outDS;
23755 +        set &outDS;
23756 +        format date best12.;
23757 +    run;
23758 +%end;
23760 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
23762 +%mend;
23766 +%macro EM_TS_Transpose(
23767 +/*-------------------------------------------------------------------------*/
23768 +  inDS          =,      /* imported data set in TS data mining             */
23769 +  inIDMap       =,      /* input TS ID map                                 */
23770 +  variableSet   =,      /* variable set                                    */
23771 +  transposeBy   =,      /* byTSID or byTimeID                              */
23772 +  outDS         =,      /* output transposed data set                      */
23773 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
23774 +  inEM          =Y,
23775 +  timePrefix    =_T
23776 +/*-------------------------------------------------------------------------*/
23777 +);
23779 +%let timePrefix = &timePrefix;
23781 +%if  &EM_NUM_CROSSID > 0 %then %do;
23783 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
23784 +    set &inIDMap;
23785 +    drop _NAMEID_;
23786 +    run;
23787 +%let inIDMap=_emtstp_map0;
23789 +%end;
23791 +proc sql noprint;
23792 +    * number of TS Variables to be transposed;
23793 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
23794 +    ;
23795 +    * number of TS Variables to be transposed;
23796 +    select max(_TSID_) into :num_TSID from &inIDMap
23797 +    ;
23798 +    * name list of TS Variables;
23799 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
23800 +        from &inIDMap
23801 +        order by _NAMEID_
23802 +    ;
23803 +    * total number of time series =max(_TSID_)*&num_TSVar;
23804 +    * and the number of digits of this variable is &num_digits;
23805 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
23806 +        from &inIDMap
23807 +    ;
23808 +      * Time ID variable;
23809 +    select name into:timeIDVar from &variableset
23810 +        where upcase(role) eq 'TIMEID'
23811 +    ;
23812 +quit;
23813 +%let num_digits = &num_digits;
23814 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
23816 +/*-------------------------------------------------------------------------*/
23818 +* get number of cross IDs and also the TIME ID variable name;
23819 +%if &inEM eq Y %then %do;
23820 +    %let num_crossIDVar = &EM_NUM_CROSSID;
23821 +    %let crossIDVar     = %EM_CROSSID;
23822 +%end;
23823 +%else %do;
23824 +    proc sql noprint;
23825 +        * number of cross ID;
23826 +        select count(*) into :num_crossIDVar
23827 +            from &variableSet
23828 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23829 +        ;
23830 +        * create a string of crossID variable like A B C D..;
23831 +        select distinct name into :crossIDVar separated by ' '
23832 +            from &variableSet
23833 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23834 +            order by name
23835 +        ;
23836 +    quit;
23837 +    %let num_crossIDVar=&num_crossIDVar;
23838 +%end;
23840 +/*-------------------------------------------------------------------------*/
23842 +%if (&num_crossIDVar gt 0) %then %do;
23844 +    data _emtstp_tmpDat;
23845 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
23846 +        _NAMEID_ = cats("_TS_",_TSID_);
23847 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
23848 +    run;
23850 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
23852 +        * update the ID maps;
23853 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
23854 +            by _NAMEID_ _TSID_;
23855 +        data &outIDMap;
23856 +            set _emtstp_tmpmap;
23857 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
23858 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
23859 +        run;
23861 +        * get the names for the new variables;
23862 +        proc sql noprint;
23863 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
23864 +            ;
23865 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
23866 +            ;
23867 +        quit;
23869 +        * data must be sorted before transposed;
23870 +        proc sort data=_emtstp_tmpDat;
23871 +            by &timeIDvar;
23872 +        run;
23874 +        %do i = 1 %to &num_TSVar;
23875 +            %let i = &i;
23876 +            * transpose one cross-type time series data by TSID;
23877 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
23878 +                id _NAMEID_;
23879 +                by &timeIDVar;
23880 +                var &&&TSVar&i;
23881 +            run;
23882 +        %end;
23884 +        * merge all vertical time series, rename and label them;
23885 +        data &outDS;
23886 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
23887 +            by &timeIDVar;
23888 +            rename
23889 +                %do i = 1 %to &num_TSVar;
23890 +                    %do j = 1 %to &num_TSID;
23891 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
23892 +                        /* %put &i &j &num1 &num_TSID; */
23893 +                        _V_&i._TS_&j = &&&tsname&num1
23894 +                    %end;
23895 +                %end;
23896 +            ;
23897 +            label
23898 +                %do i = 1 %to &num_TSVar;
23899 +                    %do j = 1 %to &num_TSID;
23900 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
23901 +                        /* %put &i &j &num1 &num_TSID; */
23902 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
23903 +                    %end;
23904 +                %end;
23905 +            ;
23906 +        run;
23907 +    %end;
23908 +    %else %do;
23910 +        * update the ID maps;
23911 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
23912 +            by _NAMEID_ _TSID_;
23913 +        data &outIDMap;
23914 +            set _emtstp_tmpmap;
23915 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
23916 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
23917 +        run;
23919 +        proc sql noprint;
23920 +            * get the roles for the new variables;
23921 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
23922 +                from &inIDMap
23923 +                order by _NAMEID_
23924 +            ;
23925 +            * get the length of the time series;
23926 +            select count(distinct &timeIDvar) into :num_T
23927 +                from _emtstp_tmpDat
23928 +            ;
23929 +        quit;
23931 +        * data must be sorted before transposed;
23932 +        proc sort data=_emtstp_tmpDat;
23933 +            by _TSID_ &crossIDVar &timeIDvar;
23934 +        run;
23936 +        %do i = 1 %to &num_TSVar;
23937 +            %let i = &i;
23938 +            * transpose one cross-type time series data by TIMEID;
23939 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
23940 +                by _TSID_ &crossIDVar;
23941 +                var &&&TSVar&i;
23942 +            run;
23943 +        %end;
23945 +        * stack all horizontal time series;
23946 +        data &outDS;
23947 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
23948 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
23949 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
23950 +            %do i=1 %to &num_TSVar;
23951 +                if in&i then do;
23952 +                    _NAMEID_ ="&&&TSVar&i";
23953 +                    _ROLE_   ="&&&TSRole&i";
23954 +                end;
23955 +            %end;
23956 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
23957 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
23958 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
23959 +        run;
23960 +    %end;
23961 +%end;
23962 +%else %do;
23964 +    proc sql noprint;
23965 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
23966 +            order by _NAMEID_
23967 +        ;
23968 +    quit;
23970 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
23971 +        * transpose the panel-type time series data by TSID;
23972 +        proc sort data=&inDS out=_emtstp_tmpDat;
23973 +            by &timeIDvar;
23974 +        proc transpose data=_emtstp_tmpDat
23975 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
23976 +            by &timeIDVar;
23977 +            var &panelTSVar;
23978 +        run;
23979 +        proc datasets lib=work nolist;
23980 +            modify _emtstp_tmpDat2;
23981 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
23982 +            run; quit;
23983 +    %end;
23984 +    %else %do;
23985 +        * transpose the panel-type time series data by TIMEID;
23986 +        proc sort data=&inDS out=_emtstp_tmpDat;
23987 +            by &timeIDvar;
23988 +        data _emtstp_tmpDat;
23989 +            set _emtstp_tmpDat;
23990 +            _tmp_ind=_n_;
23991 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
23992 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
23993 +            ID _tmp_ind;
23994 +            var &panelTSVar;
23995 +        run;
23996 +    %end;
23998 +      * merge ID maps to the transpose data set;
23999 +      proc sql noprint;
24000 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
24001 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
24002 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
24003 +          ;
24004 +      quit;
24006 +      * update the TS ID map;
24007 +      data &outIDMap;
24008 +          set &inIDMap;
24009 +      run;
24010 +%end;
24012 +proc datasets lib=work nolist;
24013 +    delete _emtstp:;
24014 +run; quit;
24016 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_REPORT.SOURCE.
24018 +/*----------------------------------------------------------------------------------+
24019 + |
24020 + |   Title :  TS Forecating Node
24021 + |
24022 + |
24023 + |   SUPPORT: Taiyeong Lee (Taiyeong.Lee@sas.com)
24024 + |
24025 + +-----------------------------------------------------------------------------------*/
24027 +%macro EM_TSESM_REPORT;
24029 +    %EM_GETNAME(KEY=OUTEST, TYPE=DATA);
24030 +    %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
24031 +    %EM_GETNAME(KEY=OUTFOR, TYPE=DATA);
24032 +    %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
24033 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
24034 +    %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
24035 +    %EM_GETNAME(KEY=OUTSTAT, TYPE=DATA);
24036 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
24037 +    %EM_GETNAME(KEY=OUTCOMPFCST, TYPE=DATA);
24038 +    %EM_GETNAME(KEY=FORCSTPLOTDS, TYPE=DATA);
24039 +    %EM_GETNAME(KEY=OUTLIERDS, TYPE=DATA);
24040 +    %EM_GETNAME(KEY=OUTSUMPLOT, TYPE=DATA);
24042 +    %EM_REPORT(key=OUTEST,    view=1, viewtype=DATA, block=MODEL, autodisplay=N, description=tsparaest ) ;
24043 +    %EM_REPORT(key=OUTSTAT,   view=2, viewtype=DATA, block=MODEL, autodisplay=N, description=tsfitstat) ;
24044 +    %EM_REPORT(key=TSIDMAP,   view=3, viewtype=DATA, block=MODEL, autodisplay=N, description=tsidmaptable) ;
24045 +    %EM_REPORT(key=OUTLIERDS, view=4, viewtype=DATA, block=MODEL, autodisplay=N, description=tsoutliertable) ;
24046 +    %EM_REPORT(key=TSMETA,    view=5, viewtype=DATA, block=MODEL, autodisplay=N, description=tsmetatable) ;
24048 +    %let viewnum=6;
24050 +    %let _num_inputs = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
24052 +    %if %EM_CROSSID eq %then %goto SKIP_HISTOGRAM;  /* panel data */
24054 +    %EM_GETNAME(key=OUTSUMHIST, type=DATA);
24055 +    %EM_GETNAME(key=OUTFCSTHIST, type=DATA);
24057 +    %let _varlist1=LOWER PREDICT UPPER;
24058 +    %let _varlist2=;
24059 +    %do k=1 %to &EM_PROPERTY_FCLEAD;
24060 +         %let _varlist2 = &_varlist2. _LEAD&k._ ;
24061 +    %end;
24062 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24063 +           %let j=1;
24064 +           %do %while(%scan(%EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED, &j) ne );
24065 +               %let _var=%scan(%EM_INTERVAL_INPUT, &j);
24066 +               data _tmp_OUTSUM;
24067 +                    set  &EM_USER_OUTSUM;
24068 +                    if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then output;
24069 +               run;
24070 +               %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=_tmp_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24071 +               %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=_tmp_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24072 +               %if &j=1 %then %do;
24073 +                   data &EM_USER_OUTSUMHIST;
24074 +                        length _VARNAME_  $32;
24075 +                        set   _tmp_OUTSUMHIST;
24076 +                        _VARNAME_="&_var";
24077 +                        label _VARNAME_ = "Variable Name";
24078 +                   run;
24079 +                   data &EM_USER_OUTFCSTHIST ;
24080 +                        length _VARNAME_  $32;
24081 +                         set _tmp_OUTFCSTHIST;
24082 +                          _VARNAME_="&_var";
24083 +                        label _VARNAME_ = "Variable Name";
24084 +                   run;
24085 +                %end;
24086 +                %else %do;
24087 +                   data  _tmp_OUTSUMHIST;
24088 +                        length _VARNAME_  $32;
24089 +                        set   _tmp_OUTSUMHIST;
24090 +                        _VARNAME_="&_var";
24091 +                        label _VARNAME_ = "Variable Name";
24092 +                   run;
24093 +                   data &EM_USER_OUTSUMHIST;
24094 +                        set &EM_USER_OUTSUMHIST  _tmp_OUTSUMHIST;
24095 +                   run;
24096 +                   data _tmp_OUTFCSTHIST ;
24097 +                        length _VARNAME_  $32;
24098 +                         set _tmp_OUTFCSTHIST;
24099 +                          _VARNAME_="&_var";
24100 +                        label _VARNAME_ = "Variable Name";
24101 +                   run;
24102 +                   data &EM_USER_OUTFCSTHIST ;
24103 +                        set &EM_USER_OUTFCSTHIST _tmp_OUTFCSTHIST ;
24104 +                   run;
24106 +                %end;
24107 +               %let j=%eval(&j+1);
24108 +           %end;
24110 +    %end;
24111 +    %else %do;
24112 +        /* Since we allow only one targt at this version */
24113 +        %let _var=%EM_TARGET;
24114 +        data _tmp_OUTSUM;
24115 +            set  &EM_USER_OUTSUM;
24116 +            if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then output;
24117 +        run;
24118 +        %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=&EM_USER_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24119 +        %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=&EM_USER_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24121 +        /*
24122 +        %VAR_PROFILE(DATA=&EM_USER_OUTSUM, OUTPUT=&EM_USER_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24123 +        %VAR_PROFILE(DATA=&EM_USER_OUTSUM, OUTPUT=&EM_USER_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24124 +        */
24125 +    %end;
24127 +    data &EM_USER_OUTSUMHIST;
24128 +         set &EM_USER_OUTSUMHIST;
24129 +         label value="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_forecastsum, noquote))";
24130 +         label Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_histogram, noquote))";
24131 +         label Percent="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
24132 +         if strip(upcase(Variable)) eq "UPPER" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_upper,noquote))";
24133 +         if strip(upcase(Variable)) eq "PREDICT" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_predict,noquote))";
24134 +         if strip(upcase(Variable)) eq "LOWER" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lower,noquote))";
24135 +         %if &_seriesFormat ^= %then %do;
24136 +            format VALUE &_seriesFormat;
24137 +         %end;
24138 +    run;
24141 +    data &EM_USER_OUTFCSTHIST;
24142 +         set &EM_USER_OUTFCSTHIST;
24143 +         length vlabel $100;
24144 +         %do k=1 %to &EM_PROPERTY_FCLEAD;
24145 +             %let _leadvar = _LEAD&k._ ;
24146 +             if upcase(strip(Variable)) ="&_leadvar" then vlabel= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_stepahead_forecast, noquote, &k))";
24147 +         %end;
24148 +         output;
24149 +         label value="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_forecast, noquote))";
24150 +         label vlabel="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_histogram, noquote))";
24151 +         label Percent="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
24152 +         %if &_seriesFormat ^= %then %do;
24153 +            format VALUE &_seriesFormat;
24154 +         %end;
24155 +    run;
24157 +    %SKIP_HISTOGRAM:
24160 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24162 +        %EM_REPORT(key=OUTSUMHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=N,
24163 +              latticex=Variable, equalizerowy=Y, equalizecoly=Y, byset=_VARNAME_, description=tsfcstsumhist, view=&viewnum);
24164 +        %let viewnum=%eval(&viewnum+1);
24165 +        %EM_REPORT(key=OUTFCSTHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=Y,
24166 +              latticex=vlabel, equalizerowy=Y, equalizecoly=Y,  byset=_VARNAME_, description=tsfcsthist, view=&viewnum);
24167 +        %let viewnum=%eval(&viewnum+1);
24168 +    %end;
24169 +    %else %do;
24170 +        %EM_REPORT(key=OUTSUMHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=N,
24171 +              latticex=Variable, equalizerowy=Y, equalizecoly=Y, description=tsfcstsumhist, view=&viewnum);
24172 +        %let viewnum=%eval(&viewnum+1);
24173 +        %EM_REPORT(key=OUTFCSTHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=Y,
24174 +              latticex=vlabel, equalizerowy=Y, equalizecoly=Y, description=tsfcsthist, view=&viewnum);
24175 +        %let viewnum=%eval(&viewnum+1);
24176 +    %end;
24178 +    %let _EndTime = ;
24179 +    %let dsid=%sysfunc(open(&EM_USER_TSMETA));
24180 +    %if &dsid > 0 %then %do;
24181 +    %let vn_end =%sysfunc(varnum(&dsid, END));
24182 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
24183 +    %do %while(^%sysfunc(fetch(&dsid)));
24184 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
24185 +       /*--------------------------------------------------------
24186 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
24187 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
24188 +        ---------------------------------------------------------*/
24189 +    %end;
24190 +    %let dsid = %sysfunc(close(&dsid));
24191 +    %end;
24193 +    %let _ndisplay = 3;
24194 +    %let _timeidVar = %EM_TIMEID;
24195 +    %let _targetVar = %EM_TARGET;
24196 +    %let _accumulate = &EM_PROPERTY_ACCUMULATE;
24199 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24201 +        %let dsid=%sysfunc(open(&EM_DATA_VARIABLESET(where=(ROLE='INPUT' and LEVEL ='INTERVAL' and USE in ('D', 'Y')))));
24202 +        %let vn_name =%sysfunc(varnum(&dsid, NAME));
24203 +        %let _autodisplay = Y;
24204 +        %let YvarString = ;
24205 +        %let i = 0;
24206 +        %do %while(^%sysfunc(fetch(&dsid)));
24207 +            %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
24208 +            %let i=%eval(&i+1);
24209 +            %let YvarString = &YvarString &_varname ;
24210 +            %if &i >  &_ndisplay %then %let _autodisplay = N;
24212 +            %let vnamefcstplot1 = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_vnamefcstplot, noquote, &_varname ));
24214 +            %if %EM_CROSSID ne %then
24215 +                  %EM_REPORT(key=FORCSTPLOTDS, viewtype=LINEBAND, block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar,
24216 +                             LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=Outlier,
24217 +                             byset=_TSID_, Description= &vnamefcstplot1, view=&viewnum);
24218 +            %else
24219 +                  %EM_REPORT(key=FORCSTPLOTDS, viewtype=LINEBAND, block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar,
24220 +                             LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=Outlier,
24221 +                             Description= &vnamefcstplot1, view=&viewnum);
24223 +            %let viewnum=%eval(&viewnum+1);
24224 +        %end;
24225 +        %let dsid = %sysfunc(close(&dsid));
24228 +        data &EM_USER_OUTCOMPFCST;
24229 +             set &EM_USER_OUTDATA;
24230 +             if &_timeidVar > &_EndTime then output;
24231 +             drop %EM_TARGET;    /* EM12 */
24232 +        run;
24234 +        %if %EM_CROSSID ne %then %do;
24236 +            /* &YVarString need to be replaced to aviod the potential length problem */
24238 +            %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, byset=_TSID_, X=&_timeidVar,
24239 +                Y=&YvarString, block=Plot, description=tsfcstcomp, view=&viewnum) ;
24240 +            %let viewnum=%eval(&viewnum+1);
24241 +            %let j=1;
24242 +            %do %while(%scan(&YvarString, &j) ne );
24243 +                %let _yvar=%scan(&YvarString, &j);
24244 +                %if &j = 1 %then
24245 +                    %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, group=_TSID_, X=&_timeidVar,
24246 +                        Y=&_yvar, block=Plot, description=mtsfcstcomp, view=&viewnum);
24247 +                %else
24248 +                    %EM_REPORT(Y=&_yvar, view=&viewnum);
24249 +                %let j=%eval(&j+1);
24251 +            %end;
24252 +            %let viewnum=%eval(&viewnum+1);
24253 +        %end;
24254 +        %else %do;
24255 +            %let j=1;
24256 +            %do %while(%scan(&YvarString, &j) ne );
24257 +                %let _yvar=%scan(&YvarString, &j);
24258 +                %if &j = 1 %then
24259 +                    %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar,
24260 +                        Y=&_yvar, block=Plot, description=tsfcstcomp, view=&viewnum);
24261 +                %else
24262 +                    %EM_REPORT(Y=&_yvar, view=&viewnum);
24263 +                %let j=%eval(&j+1);
24265 +            %end;
24266 +            %let viewnum=%eval(&viewnum+1);
24268 +            %if &j > 2 %then %do;
24269 +                %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar,
24270 +                   Y=&YvarString, block=Plot, description=mtsfcstcomp, view=&viewnum);
24271 +                %let viewnum=%eval(&viewnum+1);
24272 +            %end;
24273 +        %end;
24276 +    %end;   /* the end of  if &EM_PROPERTY_EXTINPUT eq Y */
24277 +    %else %do;
24278 +        /*
24279 +        %let _crossidvars = %EM_CROSSID;
24280 +        %let _lastcrossidvar = %SCAN(&_crossidvars, -1, %STR( ));
24281 +        %if &_lastcrossidvar eq _SEGMENT_ %then %do;
24282 +            %let _tsidVar = _SEGMENT_;
24283 +            %EM_TS_GET_STAT(data=&EM_USER_TSIDMAP, var=_SEGMENT_, stat=MAX, value=n_segments);
24284 +        %end;
24285 +        %else %do;
24286 +            %let _tsidVar = _TSID_;
24287 +        %end;
24288 +        */
24289 +        %let _tsidVar = _TSID_;
24290 +        %if &_tsidVar = _TSID_ %then %do;
24291 +            %let dsid=%sysfunc(open(&EM_USER_FORCSTPLOTDS));
24292 +            %if &dsid > 0 %then %do;
24293 +                %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24294 +                %let dsid = %sysfunc(close(&dsid));
24295 +            %end;
24296 +            %if &vn_tsid > 0 %then %do;
24297 +                %let dsid=%sysfunc(open(&EM_USER_TSIDMAP(where=(strip(_ROLE_)="TARGET"))));  /* whereclause EM12 */
24298 +                %if &dsid > 0 %then %do;
24299 +                    %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24300 +                    %do %while(^%sysfunc(fetch(&dsid)));
24301 +                        %let _tsid  = %sysfunc(getvarn(&dsid, &vn_tsid));
24302 +                        %if &_tsid < &_ndisplay %then %let _autodisplay = Y;
24303 +                        %else %let _autodisplay = N;
24304 +                        %let tsidfcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_tsidfcstplot, noquote, &_tsid ));
24305 +                        %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_TSID_ = &_tsid ),  x=&_timeidVar,
24306 +                                   LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=outlier,
24307 +                                   Description=&tsidfcstplot);
24308 +                        %let viewnum=%eval(&viewnum+1);
24309 +                    %end;
24310 +                    %let dsid = %sysfunc(close(&dsid));
24311 +                %end;
24312 +           %end;
24313 +           %else %do;  /*------ iterate over the target variables -----*/
24314 +                %let dsid=%sysfunc(open(&EM_DATA_VARIABLESET(where=(ROLE='TARGET' and LEVEL ='INTERVAL' and USE in ('D', 'Y')))));
24315 +                %let vn_name =%sysfunc(varnum(&dsid, NAME));
24316 +                %let _autodisplay = Y;
24317 +                %let i = 0;
24318 +                %do %while(^%sysfunc(fetch(&dsid)));
24319 +                    %let i=%eval(&i+1);
24320 +                    %if &i > 5 %then  %let _autodisplay = N;
24321 +                    %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
24322 +                    %let vnamefcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_vnamefcstplot, noquote, &_varname ));
24323 +                    %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar, LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL,
24323!+YPLOTTYPE=LINE, XREF=&_EndTime,  group=outlier, Description=&vnamefcstplot);
24324 +                    %let viewnum=%eval(&viewnum+1);
24325 +                %end;
24326 +                %let dsid = %sysfunc(close(&dsid));
24327 +           %end;
24328 +        %end; /* end of %if &_tsidVar = _TSID_  */
24329 +        %else %if &_tsidVar = _SEGMENT_ %then %do;
24330 +              %do i=1 %to &n_segments;
24331 +                  %if &i < &_ndisplay %then %let _autodisplay = Y;
24332 +                  %else %let _autodisplay = N;
24333 +                  %let segfcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_segfcstplot, noquote, &i, &_accumulate ));
24334 +                  %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_SEGMENT_ = &i),  x=&_timeidVar, LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE,
24334!+XREF=&_EndTime, group=outlier, Description=&segfcstplot);
24335 +                  %let viewnum=%eval(&viewnum+1);
24336 +              %end;
24337 +        %end;
24338 +         /*-------- the end of Forecasting Plot --------------------------------*/
24340 +        data &EM_USER_OUTCOMPFCST;
24341 +             set &EM_USER_OUTDATA;
24342 +            if &_timeidVar > &_EndTime then output;
24343 +            drop %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED;
24344 +        run;
24346 +        %let dsid=%sysfunc(open(&EM_USER_OUTCOMPFCST));
24347 +        %if &dsid > 0 %then %do;
24348 +            %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24349 +            %let vn_segment =%sysfunc(varnum(&dsid, _SEGMENT_));
24350 +            %let dsid = %sysfunc(close(&dsid));
24351 +        %end;
24353 +        %if (&vn_tsid > 0) and (&_targetVar ne ) %then %do;
24354 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar,block=Plot,
24355 +                            GROUP=_TSID_, WHERE=%nrbquote(_TSID_ <= 100), description=mtsfcstcomp) ;
24356 +            %let viewnum=%eval(&viewnum+1);
24357 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar,block=Plot,
24358 +                            Byset=_TSID_, WHERE=%nrbquote(_TSID_ <= 100), description=tsfcstcomp) ;
24359 +            %let viewnum=%eval(&viewnum+1);
24360 +        %end;
24361 +        %else %if &vn_segment > 0 and (&_targetVar ne ) %then %do;
24362 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar, block=Plot,
24363 +                            GROUP=_SEGMENT_, WHERE=%nrbquote(_SEGMENT_ <= 100),  description=tsfcstcomp) ;
24364 +            %let viewnum=%eval(&viewnum+1);
24365 +        %end;
24366 +        %else %if &vn_segment > 0 and (&_targetVar eq ) %then %do;
24367 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=%EM_INTERVAL_INPUT , block=Plot,
24368 +                            GROUP=_SEGMENT_, WHERE=%nrbquote(_SEGMENT_ <= 100),  description=tsfcstcomp) ;
24369 +            %let viewnum=%eval(&viewnum+1);
24370 +        %end;
24371 +        %else %do;
24372 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=%EM_TARGET , block=Plot, description=mtsfcstcomp) ;
24373 +            %let viewnum=%eval(&viewnum+1);
24375 +            %if &EM_NUM_TARGET > 1 %then %do;
24376 +                %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=_ANYNUMERIC_, block=Plot, description=tsfcstcomp) ;
24377 +                %let viewnum=%eval(&viewnum+1);
24378 +            %end;
24379 +        %end;
24381 +    %end; /* the end of  if &EM_PROPERTY_EXTINPUT eq N */
24384 +   /*------------------ plot distance map ---------------------------------*/
24386 +   %if (&EM_PROPERTY_EXPORTDATA eq KLD) %then %do;
24388 +       %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
24389 +       %EM_GETNAME(KEY=MAPDS, TYPE=DATA);
24391 +       data _tmp;
24392 +           set &EM_USER_OUTKLD;
24393 +           KEEP _TSID_ _TSID:;
24394 +       proc sort data =_tmp;
24395 +            by _TSID_;
24396 +       proc transpose data =_tmp out= &EM_USER_MAPDS Prefix=TSID_;
24397 +            by _TSID_;
24398 +       run;
24400 +       data &EM_USER_MAPDS;
24401 +           set &EM_USER_MAPDS;
24402 +           label _TSID_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24403 +           label _NAME_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24404 +           label TSID_1 ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_distmeasure, noquote))";
24405 +           rename _NAME_  =COL_VAR;
24406 +           rename TSID_1 = DISTANCE;
24407 +           ROW_VAR = "_TSID"||strip(_TSID_);
24408 +           label ROW_VAR ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24409 +       run;
24410 +       %EM_REPORT(key=MAPDS, viewtype=HISTOGRAM, Y=COL_VAR,X=ROW_VAR,
24411 +           FREQ=DISTANCE, autodisplay=Y, block=Plot, description=tssimmap, view=&viewnum);
24412 +       %let viewnum=%eval(&viewnum+1);
24413 +   %end;
24415 +   %let _xvar = ;
24416 +   %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_TSID_, exist=_isTSID);
24417 +   %if &_isTSID eq Y %then %do;
24418 +      %let _xvar = _TSID_;
24419 +      /*%EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUM, tsidds=&EM_USER_TSIDMAP, inputtype=&EM_PROPERTY_INPUTDATATYPE, outds=);*/
24420 +   %end;
24421 +   %else %do;
24422 +     %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_NAMEID_, exist=_isNAMEID);
24423 +     %if &_isNAMEID eq Y %then %let _xvar = _NAMEID_;
24424 +     %else %do;
24425 +           %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_NAME_, exist=_isNAME);
24426 +           %if &_isNAME eq Y %then %let _xvar = _NAME_;
24427 +     %end;
24428 +  %end;
24430 +  %if &_xvar ne %then %do;
24431 +        %let bysetflag = N;
24432 +         %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24433 +             data &EM_USER_OUTSUMPLOT;
24434 +                  set  &EM_USER_OUTSUM;
24435 +             %let j=1;
24436 +             %do %while(%scan(%EM_TARGET, &j) ne );
24437 +                 %let _var=%scan(%EM_TARGET, &j);
24438 +                 if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24439 +                 %let j=%eval(&j+1);
24440 +             %end;
24441 +             run;
24442 +             %if %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED)  > 1 %then %let bysetflag = Y;
24443 +        %end;
24444 +        %else %do;
24445 +             data &EM_USER_OUTSUMPLOT;
24446 +                  set  &EM_USER_OUTSUM;
24447 +                  %let j=1;
24448 +                  %do %while(%scan(%EM_INTERVAL_INPUT, &j) ne );
24449 +                  %let _var=%scan(%EM_INTERVAL_INPUT, &j);
24450 +                  if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24451 +                  %let j=%eval(&j+1);
24452 +                  %end;
24453 +                  %let j=1;
24454 +                  %do %while(%scan(%EM_INTERVAL_REJECTED, &j) ne );
24455 +                  %let _var=%scan(%EM_INTERVAL_REJECTED, &j);
24456 +                  if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24457 +                  %let j=%eval(&j+1);
24458 +                  %end;
24459 +            run;
24460 +            %if &EM_NUM_TARGET  > 1 %then %let bysetflag = Y;
24461 +        %end;
24463 +    %if %EM_CROSSID ne %then %do;
24465 +        %if &bysetflag = Y %then
24466 +            %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24467 +                byset = _NAME_, description=tsfcstsum, view=&viewnum) ;
24468 +        %else
24469 +            %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24470 +                description=tsfcstsum, view=&viewnum) ;
24472 +    %end; /* end of %if %EM_CROSSID ne %then %do; */
24473 +    %else %do;
24475 +        %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24476 +            group=_NAME_, description=tsfcstsum, view=&viewnum) ;
24477 +        *%let viewnum=%eval(&viewnum+1);
24478 +    %end;
24480 +     %do k=1 %to &EM_PROPERTY_FCLEAD;
24481 +         %let _freqvarname = _LEAD&k._ ;
24482 +         %EM_REPORT(VIEW=&viewnum, Freq=&_freqvarname);
24483 +     %end;
24484 +     %EM_REPORT(VIEW=&viewnum, Freq=LOWER);
24485 +     %EM_REPORT(VIEW=&viewnum, Freq=UPPER);
24486 +     %EM_REPORT(VIEW=&viewnum, Freq=STD);
24487 +     %EM_REPORT(VIEW=&viewnum, Freq=MIN);
24488 +     %EM_REPORT(VIEW=&viewnum, Freq=MAX);
24489 +     %EM_REPORT(VIEW=&viewnum, Freq=MEAN);
24490 +     %EM_REPORT(VIEW=&viewnum, Freq=STDDEV);
24491 +  %end; /*end of   %if &_xvar ne %then %do; */
24494 +%mend EM_TSESM_REPORT;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 264 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.13 seconds
      cpu time            0.07 seconds
 
 
 
NOTE: There were 264 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 396 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 396 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 528 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 528 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 660 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.06 seconds
 
 
 
NOTE: There were 660 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 792 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 792 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 924 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 924 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1058 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1058 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1192 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1192 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1326 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1326 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1460 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
 
 
NOTE: Line generated by the invoked macro "EM_TSESM_REPORT".
152                                                                                               drop %EM_TARGET;
                                                                                                                 -
                                                                                                                 414
 
WARNING 414-185: No DROP variables found, statement is ignored.
 
NOTE: There were 1825 observations read from the data set EMWS1.TSESM_OUTDATA.
NOTE: The data set EMWS1.TSESM_OUTCOMPFCST has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1460 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1593 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1593 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1726 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1726 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1859 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1859 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1992 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1992 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2128 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
 
 
 
NOTE: There were 4 observations read from the data set EMWS1.TSESM_OUTSUM.
NOTE: The data set EMWS1.TSESM_OUTSUMPLOT has 4 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2128 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2260 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 2260 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2392 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 2392 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2524 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2524 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2656 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 2656 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2788 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2788 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2920 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 2920 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 3052 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 3052 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 3184 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 3184 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 3316 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
 
 
24497
24498
24499  *------------------------------------------------------------*;
24500  * End REPORT: TSESM;
24501  *------------------------------------------------------------*;
 
24502  /* Reset EM Options */
24503  options formchar="|----|+|---+=|-/\<>*";
24504  options nocenter ls=256 ps=10000;
24505  goptions reset=all device=GIF NODISPLAY;
 
24506  proc sort data=WORK.EM_USER_REPORT;
24507  by ID VIEW;
24508  run;
 
NOTE: There were 3316 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 3316 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
 
 
